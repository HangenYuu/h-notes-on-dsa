---
title: "Stack"
description: "Stack"
author: "Pham Nguyen Hung"
date: last-modified
date-format: long
draft: false
toc: true
---
Firstly, See [About](https://h-notes-on-dsa.netlify.app/about.html) page.

# Stack:

## Definitions:

A data structure with the trademark of LIFO (last in, first out). It has direct analogy to the list in Python, and we actually will use the built-in list as the stack. There are alternatives to have a stack (such as `queue.LifoQueue`), but normally, a python list suffices.

## Problems:

### 1. Valid Parentheses

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
This is the [Two Sum](https://leetcode.com/problems/two-sum/) of stack. The problem requirements can be translated into the intuition that if we push the left parenthesis into a stack and pop them out whenever we encounter a right parenthesis, the correct parenthesis sequence will generate all matching pairs.

#### Approach
<!-- Describe your approach to solving the problem. -->
1. Initialize, including a HashMap for right and left parenthesis, and check that the array has an even number of elements.
2. Traverse the array of parentheses.
3. If we encounter a left parenthesis, push it to a stack.
4. If we encounter a right parenthesis, compare it to the one we pop from the stack. If they do not match, return False immediately.
5. At the end, return True if the stack is empty, else False.

#### Complexity
- Time complexity: 
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(n)$: Traversing the whole array once.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(n)$: At the worst case, we will need to store half of the array inside the stack.

#### Code
```python
class Solution:
    def isValid(self, s: str) -> bool:
        if len(s) % 2:
            return False
        stack = []
        parenthesisDict = {'{':'}', '[':']', '(':')'}
        for parenthesis in s:
            if parenthesis in parenthesisDict:
                stack.append(parenthesis)
            else:
                if len(stack) == 0 or parenthesis != parenthesisDict[stack.pop()]:
                    return False
        return len(stack) == 0
```

### 2. Evaluate Reverse Polish Notation 

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
The notation works perfectly with a stack. Basically, whenever you encounter an operand, you need to pop from the end of the stack and perform operation in the correct order before append the result to the stack. Otherwise, just append the numbers in the order we encounter them.

#### Approach
<!-- Describe your approach to solving the problem. -->
1. Traverse the list.
2. If encounter a number, append it to the stack. If encounter an operand, pop from the stack two times, operate, and append the result.
3. Return the result.

#### Complexity
- Time complexity: 
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(n)$: Traversing the whole array once.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(n)$: At the worst case, we will need to store more than half of the array inside the stack.

#### Code
```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for token in tokens:
            if token =='+':
                a, b = stack.pop(), stack.pop()
                stack.append(a+b)
            elif token =='*':
                a, b = stack.pop(), stack.pop()
                stack.append(a*b)
            elif token =='/':
                a, b = stack.pop(), stack.pop()
                stack.append(int(b/a))
            elif token =='-':
                a, b = stack.pop(), stack.pop()
                stack.append(b-a)
            else:
                stack.append(int(token))
        return stack.pop()
```

### 3. Daily Temperatures

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
The number of days to wait is the difference in the indices of the days. The stack comes in handy here by storing the value of the element sequentially, and then we pop from it when we encounter a day with larger temperature.

#### Approach
<!-- Describe your approach to solving the problem. -->
1. Initialize the stack and the `answer` array, which is an array of 0s with the same length as `temperatures`.
2. Traverse the array. Storing the value and index to a stack if the value is not larger than the last element in the stack. Pop from the stack and update `answer` otherwise.
3. Return `answer`.

#### Complexity
- Time complexity: 
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(n)$: Traversing the whole array once.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(n)$: At the worst case, we will need to store nearly the whole  array inside the stack.

#### Code
```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        answer = [0]*len(temperatures)
        stack = []
        for ind, temp in enumerate(temperatures):
            while stack and stack[-1][0] < temp:
                stackTemp, stackInd = stack.pop()
                answer[stackInd] = ind - stackInd
            stack.append((temp, ind))
        return answer
```

### 4. Min Stack

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
The trick is having another stack to store the *minimum so far*.

#### Approach
<!-- Describe your approach to solving the problem. -->
With the minimum so far stack, we just need to update it along with the main stack. The main task will be the `push` operation, where we need to append the new value if it is the new minimum, or the same last value.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
As required by the problem, everything is in $O(1)$ time.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
We are using two stacks, so it is double the memory. Nevertheless, it is $O(n)$.

#### Code
```python
class MinStack:
    # The trick is having the min stack so far
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val < self.min_stack[-1]:
            self.min_stack.append(val)
        else:
            self.min_stack.append(self.min_stack[-1])

    def pop(self) -> None:
        self.stack.pop()
        self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
```
### 5. Generate Parentheses

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
The problem gave me a taste of backtracking. It is time to realize that this is possible. Backtracking is built on recursion, which is built on the recursion call stack. So yeah, stack will be present in recursion problem.

In recursion problem, we start with the base case. The base case here revolves around the condition to add left and right parentheses. Simply, we can validly add a left parenthesis if the number of left parentheses is smaller than $n$, while we can validly add a right parenthesis if the number of left parentheses is smaller than  the number of right parentheses. The base case is when the number of left and the number of right all hit $n$.

#### Approach
<!-- Describe your approach to solving the problem. -->
1. Initialize `res` and `stack` array. One to return, one to keep track of the string generated.
2. Define the backtracking function `backtrack` based on the conditions above.
3. Call `backtrack` to update `res` and return.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(\frac{4^n}{\sqrt n})$: It is complicated to derive this time complexity, related to Catalan numbers. An alternative is remembering the brute-force time complexity: $O(2^{2n}*n)$. At each position in the $2n$ string there are two ways to choose which parenthesis to add, and checking for validity takes $O(n)$ time. 

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(n)$: The maximum depth of the recursive stack.

#### Code
```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        # Backtracking problem
        # Revolve around conditions to add open parenthesis and
        # closed parenthesis
        # Open parenthesis can be added if it is less than n
        # Closed parenthesis can be added if it is less than open
        stack, res = [], []
        
        def backtrack(openN, closedN):
            if openN == closedN == n:
                res.append(''.join(stack))
                return
            
            if openN < n:
                stack.append('(')
                backtrack(openN+1, closedN)
                stack.pop()
            
            if closedN < openN:
                stack.append(')')
                backtrack(openN, closedN+1)
                stack.pop()
        backtrack(0, 0)
        return res
```
