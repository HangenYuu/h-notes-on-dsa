---
title: "Graph"
author: "Pham Nguyen Hung"
date: last-modified
date-format: long
draft: false
toc: true
---

# Graph:

## Definitions:

- A nonlinear data structure consists of nodes connected by vertices.
- A graph can be undirected, directed, or weighted.

Graph is the generalization of linked list and tree.

The most common representation of graph in a coding interview is

- **Matrix**: Basically a list of lists storing all the nodes in a graph. The vertices are implicitly present between two nodes in the horizontal and vertical directions. 
- **Adjacency matrix**: A matrix storing the information whether a vertex exists between two nodes. This is usually the case for directed graph, because the same pair is repeated in (row, col) then (col, row). This is less frequently encountered.
- **Adjacency list**: A node will store its value and a list of all the nodes that it can go to. Commonly encountered.

Similar to tree, graph solution relies heavily on depth-first search and breadth-first search, at least for matrix, though what qualifies as DFS and BFS for matrix is different from tree.

## Problems

### 1. Number of Islands

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
From an example that I have, I thought of maintaining a count of the island `count` and a visited-or-not set `visited`. The meat will be a nested `for` loop (simplest way to search for the possible next land after finishing with an island). Of course, a helper function i.e. `dfs` will be implemented with the purpose of adding visited nodes to the set.

Depends on the requirement, if the input array can be modified, the set can be aborted and I can modify the array in-place, which saves both time and space.

#### Algorithm
<!-- Describe your approach to solving the problem. -->
Helper function:
1. Base case:
   1. Out of bound: row or column is less than 0, row or column passes the correponding length.
   2. Position is water i.e. not `'1'`.
   (3. Position already visited.)
2. Mark the position as visited.
3. Call the helper function on four adjacent tiles.

Then iterate through the tiles, call the helper function where appropriate and return the count.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(m \times n)$: This is the amortized complexity. The time complexity will be at worst in a map full of lands. The first call will prompt the algorithm to crawl over every other nodes. This operation's cost will equal to the number of edges, which is less than $O(4 \times m \times n)$. For the rest, it will be just $O(1)$. There are $m \times n$ tiles, so the cost spread out will be roughly $4$ i.e. $O(1)$ for each call. And each call will happen inside a nested for loop of $m \times n$, hence the overall cost.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(m \times n)$: The maximum size of the recursive call stack.

#### Code

In-place modification
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        count = 0
        
        def dfs(row, col):
            if min(row, col) < 0 or row >= ROWS or \
                col >= COLS or grid[row][col] != '1':
                return
            
            grid[row][col] = 'X'
            
            dfs(row - 1, col)
            dfs(row + 1, col)
            dfs(row, col - 1)
            dfs(row, col + 1)

        for row in range(ROWS):
            for col in range(COLS):
                if grid[row][col] == '1':
                    dfs(row, col)
                    count += 1

        return count
```
With another set
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        count = 0
        visited = set()
        
        def dfs(row, col):
            if min(row, col) < 0 or row >= ROWS or col >= COLS or\
                grid[row][col] != '1' or (row, col) in visited:
                return
            
            visited.add((row, col))
            
            dfs(row - 1, col)
            dfs(row + 1, col)
            dfs(row, col - 1)
            dfs(row, col + 1)

        for row in range(ROWS):
            for col in range(COLS):
                if grid[row][col] == '1' and (row, col) not in visited:
                    dfs(row, col)
                    count += 1

        return count
```

### 2. Flood Fill

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
This can be called "the easier Number of Islands". Following the same approach, but this time the starting point for depth-first search is given. Afterwards, it is performing search in all 4 directions, replacing the satisfying tiles with the value given.

#### Algorithm
<!-- Describe your approach to solving the problem. -->
For the helper function:
1. Base case: out of bound, the tile does not have the original value, the tile has already been filled.
2. Recursive: Replace the tile, then call the function on all 4 directions.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(m \times n)$: The work at every pixel is $O(1)$, and the algorithm may visit every pixel.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(m \times n)$: The maximum size of the recursive call stack.

> **Note**: No. of rows is $m$, no. of columns is $n$.

#### Code
```python
class Solution:

    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:
        ROWS, COLS = len(image), len(image[0])
        original_color = image[sr][sc]
        def dfs(row, col):
            if min(row, col) < 0 or row >= ROWS or col >= COLS or \
                image[row][col] != original_color or image[row][col] == color:
                return
            
            image[row][col] = color

            dfs(row - 1, col)
            dfs(row + 1, col)
            dfs(row, col - 1)
            dfs(row, col + 1)
        
        dfs(sr, sc)
        return image
```

### 3. Max Area of Island

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
Another variation of Number of Islands. The least memory intensive way is to return the area of each island in the recursive function and modify the input matrix in-place. However, if the input matrix needs to be intact, a set should be used to check whether a node is visited or not.

#### Algorithm
<!-- Describe your approach to solving the problem. -->
For the helper function:
1. Base case: out of bound, the tile is water, the tile has already been filled. Return 0
2. Recursive: Replace the tile value, then call the function on all 4 directions. Return 1 + the value of each direction.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(m \times n)$: The work at each tile is $O(1)$, and the algorithm will visit every tile.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(m \times n)$$ -->
$O(m \times n)$: The maximum size of the recursive call stack. Also the size of the set to keep track of nodes.

#### Code

- Modify in-place
```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        max_area = 0

        def searchArea(row, col):
            if min(row, col) < 0 or row >= ROWS or \
                col >= COLS or grid[row][col] != 1:
                return 0
            grid[row][col] = 0
            return 1 + searchArea(row + 1, col) + searchArea(row - 1, col) + searchArea(row, col + 1) + searchArea(row, col - 1)
        
        for row in range(ROWS):
            for col in range(COLS):
                if grid[row][col] == 1:
                    area = searchArea(row, col)
                    max_area = max(max_area, area)
        return max_area
```
- Another set:
```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        max_area = 0
        visited = set()

        def searchArea(row, col):
            if min(row, col) < 0 or row >= ROWS or col >= COLS \
            or grid[row][col] != 1 or (row, col) in visited:
                return 0
            visited.add((row, col))
            return 1 + searchArea(row + 1, col) + searchArea(row - 1, col) + searchArea(row, col + 1) + searchArea(row, col - 1)
        
        for row in range(ROWS):
            for col in range(COLS):
                if grid[row][col] == 1:
                    area = searchArea(row, col)
                    max_area = max(max_area, area)
        return max_area
```

### 4. Rotting Oranges

