---
title: "Graph"
author: "Pham Nguyen Hung"
date: last-modified
date-format: long
draft: false
toc: true
---

# Graph:

## Definitions:

- A nonlinear data structure consists of nodes connected by vertices.
- A graph can be undirected, directed, or weighted.

Graph is the generalization of linked list and tree.

The most common representation of graph in a coding interview is

- **Matrix**: Basically a list of lists storing all the nodes in a graph. The vertices are implicitly present between two nodes in the horizontal and vertical directions. 
- **Adjacency matrix**: A matrix storing the information whether a vertex exists between two nodes. This is usually the case for directed graph, because the same pair is repeated in (row, col) then (col, row). This is less frequently encountered.
- **Adjacency list**: A node will store its value and a list of all the nodes that it can go to. Commonly encountered.

Similar to tree, graph solution relies heavily on depth-first search and breadth-first search, at least for matrix, though what qualifies as DFS and BFS for matrix is different from tree.

## Problems

### 1. Number of Islands

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
From an example that I have, I thought of maintaining a count of the island `count` and a visited-or-not set `visited`. The meat will be a nested `for` loop (simplest way to search for the possible next land after finishing with an island). Of course, a helper function i.e. `dfs` will be implemented with the purpose of adding visited nodes to the set.

Depends on the requirement, if the input array can be modified, the set can be aborted and I can modify the array in-place, which saves both time and space.

#### Algorithm
<!-- Describe your approach to solving the problem. -->
Helper function:
1. Base case:
   1. Out of bound: row or column is less than 0, row or column passes the correponding length.
   2. Position is water i.e. not `'1'`.
   (3. Position already visited.)
2. Mark the position as visited.
3. Call the helper function on four adjacent tiles.

Then iterate through the tiles, call the helper function where appropriate and return the count.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(m \times n)$: This is the amortized complexity. The time complexity will be at worst in a map full of lands. The first call will prompt the algorithm to crawl over every other nodes. This operation's cost will equal to the number of edges, which is less than $O(4 \times m \times n)$. For the rest, it will be just $O(1)$. There are $m \times n$ tiles, so the cost spread out will be roughly $4$ i.e. $O(1)$ for each call. And each call will happen inside a nested for loop of $m \times n$, hence the overall cost.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(m \times n)$: The maximum size of the recursive call stack.

#### Code

In-place modification
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        count = 0
        
        def dfs(row, col):
            if min(row, col) < 0 or row >= ROWS or \
                col >= COLS or grid[row][col] != '1':
                return
            
            grid[row][col] = 'X'
            
            dfs(row - 1, col)
            dfs(row + 1, col)
            dfs(row, col - 1)
            dfs(row, col + 1)

        for row in range(ROWS):
            for col in range(COLS):
                if grid[row][col] == '1':
                    dfs(row, col)
                    count += 1

        return count
```
With another set
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        count = 0
        visited = set()
        
        def dfs(row, col):
            if min(row, col) < 0 or row >= ROWS or col >= COLS or\
                grid[row][col] != '1' or (row, col) in visited:
                return
            
            visited.add((row, col))
            
            dfs(row - 1, col)
            dfs(row + 1, col)
            dfs(row, col - 1)
            dfs(row, col + 1)

        for row in range(ROWS):
            for col in range(COLS):
                if grid[row][col] == '1' and (row, col) not in visited:
                    dfs(row, col)
                    count += 1

        return count
```

### 2. Flood Fill

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->

#### Approach
<!-- Describe your approach to solving the problem. -->

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

#### Code
```python
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:
        ROWS, COLS = len(image), len(image[0])
        original_color = image[sr][sc]
        def dfs(row, col):
            if min(row, col) < 0 or row >= ROWS or col >= COLS or \
                image[row][col] != original_color or image[row][col] == color:
                return
            
            image[row][col] = color

            dfs(row - 1, col)
            dfs(row + 1, col)
            dfs(row, col - 1)
            dfs(row, col + 1)
        
        dfs(sr, sc)
        return image
```