---
title: "Graph"
author: "Pham Nguyen Hung"
date: last-modified
date-format: long
draft: false
toc: true
---

# Graph:

## Definitions:

- A nonlinear data structure consists of nodes connected by vertices.
- A graph can be undirected, directed, or weighted.

Graph is the generalization of linked list and tree.

The most common representation of graph in a coding interview is

- **Matrix**: Basically a list of lists storing all the nodes in a graph. The vertices are implicitly present between two nodes in the horizontal and vertical directions. 
- **Adjacency matrix**: A matrix storing the information whether a vertex exists between two nodes. This is usually the case for directed graph, because the same pair is repeated in (row, col) then (col, row). This is less frequently encountered.
- **Adjacency list**: A node will store its value and a list of all the nodes that it can go to. Commonly encountered.

Similar to tree, graph solution relies heavily on depth-first search and breadth-first search, at least for matrix, though what qualifies as DFS and BFS for matrix is different from tree.

## Problems

### 1. Number of Islands

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
From an example that I have, I thought of maintaining a count of the island `count` and a visited-or-not set `visited`. The meat will be a nested `for` loop (simplest way to search for the possible next land after finishing with an island). Of course, a helper function i.e. `dfs` will be implemented with the purpose of adding visited nodes to the set.

Depends on the requirement, if the input array can be modified, the set can be aborted and I can modify the array in-place, which saves both time and space.

#### Algorithm
<!-- Describe your approach to solving the problem. -->
Helper function:
1. Base case:
   1. Out of bound: row or column is less than 0, row or column passes the correponding length.
   2. Position is water i.e. not `'1'`.
   (3. Position already visited.)
2. Mark the position as visited.
3. Call the helper function on four adjacent tiles.

Then iterate through the tiles, call the helper function where appropriate and return the count.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(m \times n)$: This is the amortized complexity. The time complexity will be at worst in a map full of lands. The first call will prompt the algorithm to crawl over every other nodes. This operation's cost will equal to the number of edges, which is less than $O(4 \times m \times n)$. For the rest, it will be just $O(1)$. There are $m \times n$ tiles, so the cost spread out will be roughly $4$ i.e. $O(1)$ for each call. And each call will happen inside a nested for loop of $m \times n$, hence the overall cost.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(m \times n)$: The maximum size of the recursive call stack.

#### Code

In-place modification
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        count = 0
        
        def dfs(row, col):
            if min(row, col) < 0 or row >= ROWS or \
                col >= COLS or grid[row][col] != '1':
                return
            
            grid[row][col] = 'X'
            
            dfs(row - 1, col)
            dfs(row + 1, col)
            dfs(row, col - 1)
            dfs(row, col + 1)

        for row in range(ROWS):
            for col in range(COLS):
                if grid[row][col] == '1':
                    dfs(row, col)
                    count += 1

        return count
```
With another set
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        count = 0
        visited = set()
        
        def dfs(row, col):
            if min(row, col) < 0 or row >= ROWS or col >= COLS or\
                grid[row][col] != '1' or (row, col) in visited:
                return
            
            visited.add((row, col))
            
            dfs(row - 1, col)
            dfs(row + 1, col)
            dfs(row, col - 1)
            dfs(row, col + 1)

        for row in range(ROWS):
            for col in range(COLS):
                if grid[row][col] == '1' and (row, col) not in visited:
                    dfs(row, col)
                    count += 1

        return count
```

### 2. Flood Fill

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
This can be called "the easier Number of Islands". Following the same approach, but this time the starting point for depth-first search is given. Afterwards, it is performing search in all 4 directions, replacing the satisfying tiles with the value given.

#### Algorithm
<!-- Describe your approach to solving the problem. -->
For the helper function:
1. Base case: out of bound, the tile does not have the original value, the tile has already been filled.
2. Recursive: Replace the tile, then call the function on all 4 directions.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(m \times n)$: The work at every pixel is $O(1)$, and the algorithm may visit every pixel.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(m \times n)$: The maximum size of the recursive call stack.

> **Note**: No. of rows is $m$, no. of columns is $n$.

#### Code
```python
class Solution:

    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:
        ROWS, COLS = len(image), len(image[0])
        original_color = image[sr][sc]
        def dfs(row, col):
            if min(row, col) < 0 or row >= ROWS or col >= COLS or \
                image[row][col] != original_color or image[row][col] == color:
                return
            
            image[row][col] = color

            dfs(row - 1, col)
            dfs(row + 1, col)
            dfs(row, col - 1)
            dfs(row, col + 1)
        
        dfs(sr, sc)
        return image
```

### 3. Max Area of Island

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
Another variation of Number of Islands. The least memory intensive way is to return the area of each island in the recursive function and modify the input matrix in-place. However, if the input matrix needs to be intact, a set should be used to check whether a node is visited or not.

#### Algorithm
<!-- Describe your approach to solving the problem. -->
For the helper function:
1. Base case: out of bound, the tile is water, the tile has already been filled. Return 0
2. Recursive: Replace the tile value, then call the function on all 4 directions. Return 1 + the value of each direction.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(m \times n)$: The work at each tile is $O(1)$, and the algorithm will visit every tile.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(m \times n)$$ -->
$O(m \times n)$: The maximum size of the recursive call stack. Also the size of the set to keep track of nodes.

#### Code

- Modify in-place
```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        max_area = 0

        def searchArea(row, col):
            if min(row, col) < 0 or row >= ROWS or \
                col >= COLS or grid[row][col] != 1:
                return 0
            grid[row][col] = 0
            return 1 + searchArea(row + 1, col) + searchArea(row - 1, col) + searchArea(row, col + 1) + searchArea(row, col - 1)
        
        for row in range(ROWS):
            for col in range(COLS):
                if grid[row][col] == 1:
                    area = searchArea(row, col)
                    max_area = max(max_area, area)
        return max_area
```
- Another set:
```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        max_area = 0
        visited = set()

        def searchArea(row, col):
            if min(row, col) < 0 or row >= ROWS or col >= COLS \
            or grid[row][col] != 1 or (row, col) in visited:
                return 0
            visited.add((row, col))
            return 1 + searchArea(row + 1, col) + searchArea(row - 1, col) + searchArea(row, col + 1) + searchArea(row, col - 1)
        
        for row in range(ROWS):
            for col in range(COLS):
                if grid[row][col] == 1:
                    area = searchArea(row, col)
                    max_area = max(max_area, area)
        return max_area
```

### 4. Rotting Oranges

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
The introduction to breadth-first search in matrix. I still need to expand on all 4 directions. The difference here is I need to do so in the context of layer. Simply put, the $n^{th}$ layer from the first node is all nodes that I can reach by walking $n$ steps from the first node (counting the first node as the $0^{th}$ layer). So instead of expand in each direction as far as possible, I expand all 4 nodes for each node in a layer.

#### Algorithm
<!-- Describe your approach to solving the problem. -->
1. Initialize variables: `minute` to 0, `rotten` queue for the oranges, and `fresh` to count the fresh oranges.
2. Iterate the matrix, count the number of fresh oranges and append rotten oranges to the queue.
3. While there is still fresh orange and the queue is not empty, iterate through one layer of the queue.
   1. For each node, expand to all 4 adjacent nodes.
   2. If the node is within bound and contains a fresh orange, turn it rotten, add to the queue, and decrement the number of fresh oranges.
   3. At the end, increment `minute`.
4. Return per condition.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(m \times n)$: Iterate through all the nodes in matrix roughly twice.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(m \times n)$: The maximum size of the queue.

#### Code
```python
from collections import deque
from typing import List

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        fresh = 0
        rotten = deque()
        minute = 0
        
        for row in range(ROWS):
            for col in range(COLS):
                if grid[row][col] == 1:
                    fresh += 1
                if grid[row][col] == 2:
                    rotten.append((row, col))
        
        neighbors = [[0, 1], [0, -1], [1, 0], [-1, 0]]

        while fresh > 0 and rotten:
            for _ in range(len(rotten)):
                row, col = rotten.popleft()

                for dr, dc in neighbors:
                    new_row, new_col = row + dr, col + dc
                    if (
                        0 <= new_row < ROWS
                        and 0 <= new_col < COLS
                        and grid[new_row][new_col] == 1
                    ):
                        grid[new_row][new_col] = 2
                        rotten.append((new_row, new_col))
                        fresh -= 1
            
            minute += 1
        return minute if fresh == 0 else -1
```

### 5. Shortest Path in Binary Matrix

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
Another breadth-first search problem. This time, I can move in all 8 directions. However, the principle and boilerplate is still the same.

#### Algorithm
<!-- Describe your approach to solving the problem. -->
1. Edge cases: 
1. Initialize variables: 
For the helper function:

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

#### Code
```python
from collections import deque

class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        if max(grid[0][0], grid[-1][-1]) == 1:
            return -1
        if len(grid) == 1 and grid[0][0] == 0:
            return 1

        SIZE = len(grid)
        shortest = 1
        visit = set()
        possible_steps = deque()
        
        visit.add((0, 0))
        possible_steps.append((0, 0))

        directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (-1, -1), (1, 1), (-1, 1), (1, -1)]

        while possible_steps:
            for _ in range(len(possible_steps)):
                row, col = possible_steps.popleft()
                
                for dr, dc in directions:
                    new_row, new_col = row + dr, col + dc
                    if new_row == new_col == SIZE - 1:
                        return shortest + 1
                    if (0 <= new_row < SIZE and
                        0 <= new_col < SIZE and
                        grid[new_row][new_col] == 0 and
                        (new_row, new_col) not in visit):
                        possible_steps.append((new_row, new_col))
                        visit.add((new_row, new_col))
            shortest += 1
        
        return -1
```