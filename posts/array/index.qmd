---
title: "Array"
description: "Array"
author: "Pham Nguyen Hung"
date: last-modified
date-format: long
draft: false
toc: true
---
Firstly, See [About](https://h-notes-on-dsa.netlify.app/about.html) page.

# Array:

## Definition:

The easiest, linear data structure, consisting of elements stored in contiguous memory slots. Elements are access by index, usually a number. The dictionary, or HashMap is a related data structure, consisting of key-value pairs that will be used in dealing array question.

## Problem:

### 1. Two Sum:

The **basic of basic problem**, the first problem everybody encounters when he/she starts LeetCoding.

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
Traversing the list seems like the most logical thing to do. The brute-force way is to check every pair of numbers. The time complexity is O(n^2). To optimize this, it is better to store the information we have already encountered when we traverse the list. We need to use a data structure that supports fast searching - HashMap. Either way works, but the HashMap can be used for storing the index of the element as well. If we store an element as the key and the index as the value, we can quickly search and return the indices.

#### Approach
<!-- Describe your approach to solving the problem. -->
The algorithm can be described as:

1. Traverse the array from the beginning.
2. Store the element encountered in a set/dictionary.
3. Check if the sum - element is in the dictionary.
4. Return the indices.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(n)$: Traversing the whole list once.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(n)$: In the worst case, we will have a dictionary with a size equal to the array.

#### Code
```python
from collections import defaultdict
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        numsDict = defaultdict(int)
        for ind, num in enumerate(nums):
            if target-num in numsDict:
                return [ind, numsDict[target-num]]
            numsDict[num] = ind
```

### 2. Contains Duplicate

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
Again, traverse the array, storing information about what we have encountered. This time, we only need to store the element itself, so a HashSet suffices.

#### Approach
<!-- Describe your approach to solving the problem. -->
1. Traverse the array.
2. Check if the current element is in the HashSet. If it is, return True for duplicate.
3. If we reach the end of the array, return False for no duplicate.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(n)$: Traversing the whole list once.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(n)$: In the worst case, we will have a set with a size equal to the array.

#### Code
```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        numSet = set()
        for num in nums:
            if num in numSet:
                return True
            numSet.add(num)
        return False
```

### 3. Valid Anagram:

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
Again, traverse the array, storing information about what we have encountered. This time, we only need to store the element itself, so a HashSet suffices.

#### Approach
<!-- Describe your approach to solving the problem. -->
1. Traverse the array.
2. Check if the current element is in the HashSet. If it is, return True for duplicate.
3. If we reach the end of the array, return False for no duplicate.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(n)$: Traversing the whole list once.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(n)$: In the worst case, we will have a set with a size equal to the array.

#### Code
```python
from collections import defaultdict
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        hashS, hashT = defaultdict(int), defaultdict(int)
        for index in range(len(s)):
            hashS[s[index]] += 1
            hashT[t[index]] += 1
        return hashS == hashT
```

### 4. Majority Element

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
There are many approaches to the problem. The simplest way except brute-force the whole thing is to use a HashMap to count the number of occurences of each element (in Python can be done faster with `collections.Counter`). The solution provided is to deal with the follow-up question of linear time with $O(1)$ memory.

#### Approach
<!-- Describe your approach to solving the problem. -->
This is a named algorithm: Boyer-Moore Voting Algorithm. The procedure is this: while we traverse the array, if we choose the first element as a candidate and consider three things:

1. An encounter with the same element a vote for the candidate
2. An encounter with a difference element a vote against the candidate
3. Change the candidate to the current element if it is different than the candidate and the vote for the candidate has become 0

then at the end, we should be left with the candidate.

This is because the majority element will occur more than `n//2` times with `n` the length of the array. Because of this, the majority element will be the only possible candidate with a positive vote at the end.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(n)$: We need to traverse the array once.
- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(1)$: We only need to keep track of the count and the candidate, which requires constant memory.

#### Code
```python
class Solution:
    def majorityElement(self, nums):
        count = 0
        candidate = None

        for num in nums:
            if count == 0:
                candidate = num
            count += (1 if num == candidate else -1)

        return candidate
```

### 5. Group Anagrams

#### Intuition

From [Valid Anagram](https://leetcode.com/problems/valid-anagram/), we know that one word is an anagram of another if character frequencies are the same. We can check everything in one go with a dictionary. The key information is *lowercase letter only*. This means that character frequency can be capture in a tuple of 26 number, each one the number of character a, b, etc. in the word. We can append each word to the correct key in the dictionary. Afterwards, we simply return the values of the dictionary.

#### Approach

1. Initialize a dictionary, better with Python `defaultdict`.
2. Iterate the list of words. For each word, initialize an array of 26 0s and increment the correct count for each character. `ord()` is useful in this case.
3. Append the word to the value array of the correct key.
4. Return the values of the dictionary.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(nk)$: We need to traverse the array once. $k$ is the maximum length of a string in the array.
- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(nk)$: The information stored in the dictionary.
#### Code
```python
from collections import defaultdict
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        countDict = defaultdict(list)
        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            countDict[tuple(count)].append(s)
        return countDict.values()
```

### 6. Top K Frequent Elements

#### Intuition

To satisfy the $O(nlogn)$ time constraint, computer science students will think of Quickselect. If you know how to implement Quickselect, it's fine.

For someone who doesn't, the approach is to use a dictionary the frequency as the key, and the value an array of elements with that key. To return, we can just iterate the dictionary from the maximum value to the minimum, append the value to an array and return the k elements.
#### Approach

1. Take frequency count of the elements in the array, better with Python `Counter`
2. Initialize a dictionary, better with Python `defaultdict`.
3. Iterate the array. Append each element to the value of the correct key.
4. Iterate the dictionary from the maximum value down for the top-k elements and return it.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(n)$: We need to traverse the array once and the dictionary once. Worst-case, the dictionary has the same size as the array.
- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(n)$: Worst-case, we will need to store triple the memory of the original array.
#### Code
```python
from collections import defaultdict, Counter
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        count = Counter(nums)
        ans = defaultdict(list)
        for num in count:
            ans[count[num]].append(num)
        top = max(ans)
        res = []
        for i in range(top,-1,-1):
            res.extend(ans[i])
        return res[:k]
```
Optimized solution from NeetCode
```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # Bucket Sort
        countDict = {}
        for i in nums:
            countDict[i] = countDict.get(i, 0) + 1
        freqList = [[] for i in range(len(nums))]
        for num, count in countDict.items():
            freqList[count-1].append(num)
        res = []
        for i in range(len(freqList) - 1, 0, -1):
            for n in freqList[i]:
                res.append(n)
                if len(res) == k:
                    return res
```