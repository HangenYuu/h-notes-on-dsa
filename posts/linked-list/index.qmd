---
title: "Linked List"
description: "Linked List"
author: "Pham Nguyen Hung"
date: last-modified
date-format: long
draft: false
toc: true
---
Firstly, See [About](https://h-notes-on-dsa.netlify.app/about.html) page.

# Linked List:

## Definitions:

- A nonlinear data structure consists of nodes with pointers to the next nodes.
- A linked list can be singly-linked, or doubly-linked, with just head pointer or together with tail pointer.
- For LeetCode, a singly-linked list with head pointer is usually given.
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```
- May fall under many patterns, such as fast and slow pointers.

## General trick:

### 1. Sentinel head (also tail):

I create a dummy head first, modify everything after, and then return the actual head with `dummy.next`
```python
dummy = ListNode(None)
head = dummy
# Do a lot of stuff with head
return dummy.next
```
This is useful as I can use the `head` as a pointer to traverse the linked list while still need to return the head of the linked list in result. 

## Problems:

### 1. Reverse Linked List

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
This is a **basic problem** - a problem that can be become a sub-problem for a bigger task in the future LeetCode problems. This is like a formula that you have to remember, and then exploit it over and over again.

#### Algorithm
<!-- Describe your approach to solving the problem. -->
When dealing with Linked List, the king is pointer - ~~something as dangerous as pointing gun to your head~~an object that points to the particular position of a node in the list. The number of pointers a problem requires depend on the amount of information I need at when processing each node in the list. Here, I need to know 3 pieces: the current node (obviously), the previous node to point the current node to, and the next node to move the pointer. Hence, I will use three pointers - `pre`, `cur`, and `nex` to keep track while traversing the list.

#### Complexity
- Time complexity: $O(n)$: Traversing the whole list once.
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

- Space complexity: $O(1)$: Pointers are essentially integers, taking constant memory
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

#### Code
```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # Easy case:
        if head is None or head.next is None:
            return head
        
        # General case:
        pre, cur, nex = None, head, head.next
        while nex:
            cur.next = pre
            pre = cur
            cur = nex
            nex = nex.next
        cur.next = pre
        return cur
```

### 2. Reverse Nodes in k-Group

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
The problem is twofold: getting the $k^{th}$ node from the linked list (which is easy) and reverse *just* $k$ *nodes* of the linked list, which is tricky.

I look at the algorithm to reverse the whole linked list, the hint is knowing the node right before the head of the group to point the tail to, and knowing the node right after the tail of the group to point the head to. The big problem is implementation.

For implementation, the node right before can be initialized as a dummy node first pointing to the head of the input linked list. The purpose is two fold. After all operations, the head of the return linked list can be accessed as `dummy.next`. Furthermore, the head of a group can be accessed as `previous_to_group.next`, while the node right after the group is `next_to_group.next`.

#### Algorithm
<!-- Describe your approach to solving the problem. -->
1. Initialize `dummy` node and `previous_to_group`.
2. Iterate the linked list:
   1. Get the $k^{th}$ i.e., the tail of a group and node right after it.
   2. Reverse this k-node group.
   3. Set `previous_to_group` for the next iteration.
3. Return `dummy.next` i.e., the head of the new linked list

Step 2. is implemented as a separate method.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(n)$: I need to iterate the linked list twice.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(1)$: I only need to store pointers.

#### Code
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        dummy = ListNode(0, head)
        previous_to_group = dummy # Node right before the group

        while True:
            kth_node = self.getKthNode(previous_to_group, k)
            if not kth_node:
                break
            next_to_group = kth_node.next

            # Reverse k nodes
            prev, curr = kth_node.next, previous_to_group.next

            while curr != next_to_group:
                temp = curr.next
                curr.next = prev
                prev = curr
                curr = temp
            
            temp = previous_to_group.next
            previous_to_group.next = kth_node
            previous_to_group = temp
        return dummy.next

    def getKthNode(self, current_node, k):
        while current_node and k > 0:
            current_node = current_node.next
            k -= 1
        return current_node
```

### 3. Reverse Linked List II

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
I love the course "Grokking Coding Interview Pattern". However, I have a feeling I have been scared. Reverse Linked List turns out to be a subproblem for Reverse Nodes in k-Group. The problem gives you two limits and asks you to reverse the nodes between the limits. The implementation is different from Reverse Nodes in k-Group as I reverse with `range` now, but the principle is exactly the same.

#### Algorithm
<!-- Describe your approach to solving the problem. -->
1. Initialize `dummy` node.
2. Iterate the linked list $left-1$ times to get the node right before the group.
3. Get the left node of the group and reverse the connections of $right-left+1$ nodes in the group.
4. Reconnect the new head and tail of the group to the nodes right before and right after.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(n)$: I iterate the linked list exactly once.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(1)$: I only need to store pointers.

#### Code
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        # Edge case
        if not head or left == right:
            return head
        
        dummy = ListNode(0, head)
        prev_of_group = dummy
        for _ in range(left-1):
            prev_of_group = prev_of_group.next
        
        # Reverse node
        prev, curr = None, prev_of_group.next
        for _ in range(right-left+1):
            temp = curr.next
            curr.next = prev
            prev = curr
            curr = temp
        # Now prev is the head of the new group, and curr is the node right after the group
        prev_of_group.next.next = curr
        prev_of_group.next = prev
        return dummy.next

```