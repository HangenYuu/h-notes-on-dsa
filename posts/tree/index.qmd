---
title: "Tree"
description: "Mostly binary tree"
author: "Pham Nguyen Hung"
date: last-modified
date-format: long
draft: false
toc: true
---
Firstly, See [About](https://h-notes-on-dsa.netlify.app/about.html) page.

# Tree

## Definitions

The upgraded version of a linked list.

- It is acyclic (doesn't contain any cycles);
- There exists a path from the root to any node;
- Has $N - 1$ edges, where $N$ is the number of nodes in the tree; and
- Each node has exactly one parent node with the exception of the root node.

For binary tree, all nodes have at most 2 children.
```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```
| Terms | Meaning |
| ----- | ------- |
| Node & Edges  | Trivia |
| Root          | The first node |
| Leaf node     | Node with no child |
| Internal node | Node with at least one child |
| Ancestor      | Nodes that are between the path<br/>from the root to the current root.<br/> Including the node itself |
| Descendent    | Nodes that are between the path<br/>from the root to the current root.<br/> Including the node itself |
| Level         | Number of ancestors from that node<br/>until the root node. Start at 0 or 1, go down. |
| Height        | Number of edges on the longest path from<br/>that node to a leaf. Start at 0, go up. |
| Depth         | Number of edges on the path from root<br/>to that node. Start at 0, go down. |


## Categories

**Full binary tree**
: Every node has 0 or 2 children.

**Complete binary tree**
: All levels are completely filled except possibly the last level. All nodes are as far left as possible.

**Perfect binary tree**
: All internal nodes have two children and all leaf nodes have the same level

**Balanced binary tree**
: Every node fulfil the condition: height difference of the left and right subtree of the node is not more than than 1. Searching, insertion, and deletion in a balanced binary tree takes $O(logn)$ instead of $O(n)$ in an unbalanced binary tree.

## Notes:

### 1. Breadth-first search
**Breadth-first search** is first heavily used technique. Here's the template adapted from [LeetCode Explore](https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1372/):
```python
from collections import deque

def BFS(root, target):
    queue = deque() # store all nodes which are waiting to be processed
    visited = set() # store all the nodes that we've visited
    step = 0 # number of steps needed from root to current node
    # initialize
    queue.append(root)
    visited.add(root)
    # BFS
    while queue:
        # iterate the nodes which are already in the queue
        size = len(queue)
        for i in range(size):
            cur = queue.popleft()
            if cur == target:
                return step
            for next in cur.neighbors:
                if next not in visited:
                    queue.append(next)
                    visited.add(next)
        step += 1
    return -1 # there is no path from root to target
```
This template uses a set to track the node visited. In a graph, as a cycle is possible, this is necessary. However, because a tree is acyclic, it is not necessary

```python
from collections import deque

def BFS(root, target):
    queue = deque() # store all nodes which are waiting to be processed
    # visited = set() # store all the nodes that we've visited
    step = 0 # number of steps needed from root to current node
    # initialize
    queue.append(root)
    # visited.add(root)
    # BFS
    while queue:
        # iterate the nodes which are already in the queue
        size = len(queue)
        for i in range(size):
            cur = queue.popleft()
            if cur == target:
                return step
            if cur.left:
                queue.append(cur.left)
            if cur.right:
                queue.append(cur.right)
        step += 1
    return -1 # there is no path from root to target
```

### 2. Depth-first search

**Depth-first search** is the second heavily used technique. It is essentially *pre-order traversal* of a tree. All traversal types are given here:
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

    def pre_order_traversal(self, root: TreeNode):
        if root is not None:
            print(root.val)
            pre_order_traversal(root.left)
            pre_order_traversal(root.right)

    def in_order_traversal(self, root: TreeNode):
        if root is not None:
            in_order_traversal(root.left)
            print(root.val)
            in_order_traversal(root.right)
    
    def post_order_traversal(self, root: TreeNode):
        if root is not None:
            post_order_traversal(root.left)
            post_order_traversal(root.right)
            print(root.val)
```
Here's the template from AlgoMonster:
```python
def dfs(root, target):
    if root is None:
        return None

    if root.val == target:
        return root
    left = dfs(root.left, target)

    if left is not None:
        return left
    return dfs(root.right, target)
```

Depth-first search is often implemented in recursion. In thinking in recursion, the most important thing is visualization of the call stack. 

In thinking in recursion, one must forget the whole picture and start thinking about each node. For each node, decide how the information there should be processed, then recurse on the children. When you are a node, the only thing you know are 1. node value and 2. how to get to children. The recursive function should manipulate these things.

In defining the recursive functions, there are two things to decide when we define:

1. `return` value - the value the child passes to the parent. For example, for the max depth problem this is the max depth for the current node's subtree.
2. state - the value the parent passes to the child. For example, to know if the current node's value is larger than its parent we have to maintain the parent's value as a state.

Another way to solve the problem is to replace `return` value with a global variable.

## Problems

### 1. Flatten Binary Tree to Linked List

#### Intuition

Depth-first search is recursion. The problem is constructing a repeatable sequence that can lead to the final result. The hint was "it looks like pre-order traversal". It was about traversing to the left child first after the current node. But the key sequence is *from the root, attaching the right child to the rightmost node in the left subtree, and move the left child i.e., the root of the left subtree to the right*. And then move on to the right child, formerly the left child.

#### Algorithm
<!-- Describe your approach to solving the problem. -->
1. Traverse the binary tree, check the existsnce of the left child of the current node.
2. If the left child exists, find the rightmost node in the left subtree.
3. Set the right child of the current node as the right child of the rightmost node above.
4. Set the left child of the current node as its right child.
5. Set the left child of the current node as None.
6. Move to the right child

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(n)$: Iterate the binary tree.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(1)$: The tree is modified in-place.

#### Code
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        # Edge case
        if not root:
            return
        
        # General case
        current = root
        while current:
            if current.left:
                last = current.left
                
                while last.right:
                    last = last.right
                
                last.right = current.right
                current.right = current.left
                current.left = None
            
            current = current.right
```

### 2. Binary Tree Level Order Traversal

#### Intuition

The question asks you and me to implement breadth-first search. So let's do it.

#### Algorithm
<!-- Describe your approach to solving the problem. -->
1. Initialize a queue to store all nodes of each level, start with `root`.
2. Take the current `level_length` and operates on the queue for `level_length` time:
   1. Pop from the left of the queue and add the value to a list for the level.
   2. Add the children to the queue.
3. Add the list of values of each level to the return list.
4. Return.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(n)$: Iterate the binary tree.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(n)$: The size of the queue is `n // 2` in the worst case.

#### Code
```python
from typing import (
    List,
)
from lintcode import (
    TreeNode,
)
from collections import deque
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: A Tree
    @return: Level order a list of lists of integer
    """
    def level_order(self, root: TreeNode) -> List[List[int]]:
        # write your code here
        # Edge case
        if not root:
            return []
        
        # General case
        queue = deque()
        result = []
        queue.append(root)

        while queue:
            level = []
            level_length = len(queue)
            for _ in range(level_length):
                node = queue.popleft()
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            result.append(level)
        return result
```

### 3. Binary Tree Zigzag Level Order Traversal

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
Sounds like Level order traversal plus reversing the level-wise traversal every two levels. One incorecct answer is reversing the order of appending children nodes to the levelwise traversal but it is wrong as it does not fully reverse the order of traversal.

A better solution is using a double-ended queue i.e., deque. This one supports `appendleft()`, so if the current level should be reversed, the operations can be switched from `popleft()` then `append()` to `pop` then `appendleft()`.

#### Algorithm
<!-- Describe your approach to solving the problem. -->
1. Perform level order traversal. Reverse the levelwise traversal every two levels.
2. Return the traversal.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(n)$: Some level is effectively traversed twice, but the overall is still $O(n)$

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(n)$: THe size of the queue.

#### Code
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from collections import deque

class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        # Edge case
        if not root:
            return []
        
        # General case
        queue = deque([root])
        level = 1
        zigzag_traversal = []
        while queue:
            level_traversal = []
            level_length = len(queue)

            if level % 2:
                for _ in range(level_length):
                    node = queue.popleft()
                    level_traversal.append(node.val)

                    if node.left:
                        queue.append(node.left)
                    if node.right:
                        queue.append(node.right)
            else:
                for _ in range(level_length):
                    node = queue.pop()
                    level_traversal.append(node.val)

                    if node.right:
                        queue.appendleft(node.right)
                    if node.left:
                        queue.appendleft(node.left)
                    
            if level % 2:
                level_traversal = level_traversal[::-1]
            zigzag_traversal.append(level_traversal)
            level += 1
        return zigzag_traversal
```

### 4. Populating Next Right Pointers in Each Node

#### Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
Breadth-first search makes the most sense in this problem. However, the question is how to do the problem in $O(1)$ extra memory. That means using only pointers and do away with the queue. How?

I remember from the introduction that the purpose of the `next` pointer is to do away with the queue in level order traversal. And the (only) way I connect them is connecting the child level of a node i.e., pointing the left child to the right child. This means that when I arrive at a level, all the nodes should already be connected and I can just traverse with `next` pointer. And as said above, connecting the left child of a node to the right child is trivial. To connect the right child of a node the next left child, I need to use the `next` pointer of the current node. Implementation was straightforward, but coming up with the concept is crazy.

#### Algorithm
<!-- Describe your approach to solving the problem. -->
1. Initialize a pointer pointing to the current node and a pointer pointing to the first node of a level.
2. Traverse the current level, connecting the node of the next level.
3. Once having reached the end, move to the next level and update pointers.
4. Return at the end.

#### Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
$O(n)$: Traverse every node in the tree.

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
$O(1)$: Only use pointers to connect new nodes together.

#### Code
```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""
class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        current_node, start_next_level = root, root.left if root else None

        while current_node and start_next_level:
            current_node.left.next = current_node.right
            if current_node.next:
                current_node.right.next = current_node.next.left
            
            current_node = current_node.next
            if not current_node:
                current_node = start_next_level
                start_next_level = current_node.left
        
        return root
```