[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "H’s notes on Data Structuress and Algorithms",
    "section": "",
    "text": "Graph\n\n\n\n\n\nGraph\n\n\n\n\n\n\nFeb 10, 2023\n\n\nAlan Smithee\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/graph/index.html",
    "href": "posts/graph/index.html",
    "title": "Graph",
    "section": "",
    "text": "A nonlinear data structure consists of nodes connected by vertices.\nA graph can be undirected, directed, or weighted.\n\n\n\n\nRepresented as a data structures in LeetCode’s terminology\nHelps to register the connectivity of a graph/network. Consists of two arrays:\n\nStore the node itself (represented by index)\nStore the parent/root vertex of the node\n\nThe problem of checking connectivity is reduced to the problem of checking whether two nodes have the same root node.\nThe disjoint set has two essential methods: find() and union(). find() : find the root node of a given vertex\n\nunion()\n\nunions two vertices and makes their root nodes the same\n\n\n\n\n\nStart with creating an array with array[i]=i\nCan implement with emphasis on find() (Quick Find) or union() (Quick Union)\n\n\n\n\nInstead of storing the parent node, the array will store the root node straight-away. This makes for a quick find() but slower union() as we need to search the entire array.\n\n# UnionFind class\nclass UnionFind:\n    def __init__(self, size):\n        self.root = [i for i in range(size)]\n\n    def find(self, x):\n        return self.root[x]\n        \n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            for i in range(len(self.root)):\n                if self.root[i] == rootY:\n                    self.root[i] = rootX\n\n    def connected(self, x, y):\n        return self.find(x) == self.find(y)\n\n\n# Test Case\nuf = UnionFind(10)\n# 1-2-5-6-7 3-8-9 4\nuf.union(1, 2)\nuf.union(2, 5)\nuf.union(5, 6)\nuf.union(6, 7)\nuf.union(3, 8)\nuf.union(8, 9)\nprint(uf.connected(1, 5))  # true\nprint(uf.connected(5, 7))  # true\nprint(uf.connected(4, 9))  # false\n# 1-2-5-6-7 3-8-9-4\nuf.union(9, 4)\nprint(uf.connected(4, 9))  # true\n\nTrue\nTrue\nFalse\nTrue\n\n\n\n\n\n\n\n\nUnion-Find Constructor\nFind\nUnion\nConnected\n\n\n\n\nTime Complexity\n\\(O(N)\\)\n\\(O(1)\\)\n\\(O(N)\\)\n\\(O(1)\\)\n\n\n\nThe Union-Find Constructor is 1-liner in Python but it takes linear time to initialize in the system. #### Space Complexity: \\(O(N)\\) to store each node.\n\n\n\n\nunion() stops at setting the root node of the child to the root node of the parent only. find() and connected() will need to traverse more to find the answer. The worst-case time complexity for each operation swells to \\(O(N)\\), but the overall efficiency goes up.\n\n# UnionFind class\nclass UnionFind:\n    def __init__(self, size):\n        self.root = [i for i in range(size)]\n\n    def find(self, x):\n        while x != self.root[x]:\n            x = self.root[x]\n        return x\n        \n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            self.root[rootY] = rootX\n\n    def connected(self, x, y):\n        return self.find(x) == self.find(y)\n\n\n# Test Case\nuf = UnionFind(10)\n# 1-2-5-6-7 3-8-9 4\nuf.union(1, 2)\nuf.union(2, 5)\nuf.union(5, 6)\nuf.union(6, 7)\nuf.union(3, 8)\nuf.union(8, 9)\nprint(uf.connected(1, 5))  # true\nprint(uf.connected(5, 7))  # true\nprint(uf.connected(4, 9))  # false\n# 1-2-5-6-7 3-8-9-4\nuf.union(9, 4)\nprint(uf.connected(4, 9))  # true\n\nTrue\nTrue\nFalse\nTrue\n\n\n\n\n\n\n\n\nUnion-Find Constructor\nFind\nUnion\nConnected\n\n\n\n\nTime Complexity\n\\(O(N)\\)\n\\(O(N)\\)\n\\(O(N)\\)\n\\(O(N)\\)\n\n\n\nThe Union-Find Constructor is 1-liner in Python but it takes linear time to initialize in the system.\nNumber of operations to get to the root vertex will be H, where H is the height of the tree. In the worst case, H = N if the graph is a linked list.\n\n\n\n\\(O(N)\\) to store each node.\n\n\n\n\nFirst, observe that the smaller the height of the tree, the more efficient the algorithms run. So we will want to balance the tree as much as we can, but not to try too hard. One way to do so is union by rank. Rank here refers to the height of the vertex. When we union two vertices, instead of just picking the root node of one, we choose the root node of the vertex with a larger “rank”. We will merge the shorter tree under the taller tree and assign the root node of the taller tree as the root node for both vertices.\nThis is an optimization for Quick Union. To implement this, we need to make 2 changes:\n\nAdding an array rank to keep track of the rank of each vertex.\nModify the codes of union(). It is easy for the case of unequal rank. For the case of equal rank, we will assign one to the other (say, set root of Y to root of X) and increase the height of the other vertex (X’s height += 1).\n\n\n# UnionFind class\nclass UnionFind:\n    def __init__(self, size):\n        self.root = [i for i in range(size)]\n        self.rank = [1] * size\n\n    def find(self, x):\n        while x != self.root[x]:\n            x = self.root[x]\n        return x\n        \n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            if self.rank[rootX] > self.rank[rootY]:\n                self.root[rootY] = rootX\n            elif self.rank[rootX] < self.rank[rootY]:\n                self.root[rootX] = rootY\n            else:\n                self.root[rootY] = rootX\n                self.rank[rootX] += 1\n\n    def connected(self, x, y):\n        return self.find(x) == self.find(y)\n\n\n# Test Case\nuf = UnionFind(10)\n# 1-2-5-6-7 3-8-9 4\nuf.union(1, 2)\nuf.union(2, 5)\nuf.union(5, 6)\nuf.union(6, 7)\nuf.union(3, 8)\nuf.union(8, 9)\nprint(uf.connected(1, 5))  # true\nprint(uf.connected(5, 7))  # true\nprint(uf.connected(4, 9))  # false\n# 1-2-5-6-7 3-8-9-4\nuf.union(9, 4)\nprint(uf.connected(4, 9))  # true\n\nTrue\nTrue\nFalse\nTrue\n\n\n\n\n\n\n\n\nUnion-Find Constructor\nFind\nUnion\nConnected\n\n\n\n\nTime Complexity\n\\(O(N)\\)\n\\(O(logN)\\)\n\\(O(logN)\\)\n\\(O(logN)\\)\n\n\n\n\nThe Union-Find Constructor is 1-liner in Python but it takes linear time to initialize in the system.\nTree height will be at most log(N) + 1 when we repeatedly union components of equal rank, so find() will take O(logN) in the case.\nunion() and connected() depends on find(), so they need O(logN) as well.\n\n\n\n\n\\(O(N)\\) to store the value and the rank of each node.\n\n\n\n\nAfter finding the root node, we update the parent node of all traversed elements to their root node. We implement this with recursion.\n\n# UnionFind class\nclass UnionFind:\n    def __init__(self, size):\n        self.root = [i for i in range(size)]\n\n    def find(self, x):\n        if x == self.root[x]:\n            return x\n        self.root[x] = self.find(self.root[x])\n        return self.root[x]\n        \n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            self.root[rootY] = rootX\n\n    def connected(self, x, y):\n        return self.find(x) == self.find(y)\n\n\n# Test Case\nuf = UnionFind(10)\n# 1-2-5-6-7 3-8-9 4\nuf.union(1, 2)\nuf.union(2, 5)\nuf.union(5, 6)\nuf.union(6, 7)\nuf.union(3, 8)\nuf.union(8, 9)\nprint(uf.connected(1, 5))  # true\nprint(uf.connected(5, 7))  # true\nprint(uf.connected(4, 9))  # false\n# 1-2-5-6-7 3-8-9-4\nuf.union(9, 4)\nprint(uf.connected(4, 9))  # true\n\nTrue\nTrue\nFalse\nTrue\n\n\n\n\n\n\n\n\nUnion-Find Constructor\nFind\nUnion\nConnected\n\n\n\n\nTime Complexity\n\\(O(N)\\)\n\\(O(logN)\\)\n\\(O(logN)\\)\n\\(O(logN)\\)\n\n\n\n\nThe Union-Find Constructor is 1-liner in Python but it takes linear time to initialize in the system.\nThe worst-case call of find() will take O(N), but it will take O(1) afterwards. Average out, it takes O(logN) time to perform.\nunion() and connected() depends on find(), so they need O(logN) as well.\n\n\n\n\n\\(O(N)\\) to store the value and the rank of each node.\n\n\n\n\n\n# UnionFind class\nclass UnionFind:\n    def __init__(self, size) -> None:\n        \"\"\"\n        Function to initialize the UnionFind class\n\n        :param size: the number of nodes in the set\n        :return: None\n        \"\"\"\n        self.root = [i for i in range(size)]\n        self.rank = [1]*size\n    \n    def find(self, node):\n        \"\"\"\n        Function to return the root of a node. Recursively\n        modify the parent node if it is not yet the root\n\n        :param node: the node to search root for\\\n        :return: the root node\n        \"\"\"\n        if node == self.root[node]:\n            return node\n        # Parent node is not itself and possibly not the\n        # root node\n\n        # Set the root of node to the root of the parent node\n        # of node\n        self.root[node] = self.find(self.root[node])\n        return self.root[node]\n\n    def union(self, node1, node2):\n        root1 = self.find(node1)\n        root2 = self.find(node2)\n        # Do nothing if the two nodes are already connected\n        # Set the root of both nodes to the root of the node\n        # with heigher rank (height)\n        # In case of equal rank, set to the root of one node\n        # and increase the rank of that node\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.root[root2] = root1\n            elif self.rank[root1] < self.rank[root2]:\n                self.root[root1] = root2\n            else:\n                self.root[root2] = root1\n                self.rank[root1] += 1\n    \n    def connected(self, node1, node2):\n        return self.find(node1) == self.find(node2)\n            \n\n# Test Case\nuf = UnionFind(10)\n# 1-2-5-6-7 3-8-9 4\nuf.union(1, 2)\nuf.union(2, 5)\nuf.union(5, 6)\nuf.union(6, 7)\nuf.union(3, 8)\nuf.union(8, 9)\nprint(uf.connected(1, 5))  # true\nprint(uf.connected(5, 7))  # true\nprint(uf.connected(4, 9))  # false\n# 1-2-5-6-7 3-8-9-4\nuf.union(9, 4)\nprint(uf.connected(4, 9))  # true\n\nTrue\nTrue\nFalse\nTrue\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUnion-Find Constructor\nFind\nUnion\nConnected\n\n\n\n\nTime Complexity\n\\(O(N)\\)\n\\(O(\\alpha(N))\\)\n\\(O(\\alpha(N))\\)\n\\(O(\\alpha(N))\\)\n\n\n\n\\(\\alpha(N)\\) is the inverse Ackermann function, which is \\(O(1)\\) on average.\n\n\n\n\\(O(N)\\) to store the value and the rank of each node."
  }
]