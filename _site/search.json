[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog\nThis blog is mostly for my own study of data structures and algorithms and LeetCode questions. Therefore, it lacks the normal structure of a study resource for audience, especially for the LeetCode questions mentioned. There will be no problem statements, constraints, etc., only notes on intuition, approach, and code solutions with comments. Please open the corresponding LeetCode/LintCode questions while reading."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "H’s notes on Data Structuress and Algorithms",
    "section": "",
    "text": "Linked List\n\n\n\n\n\nLinke List\n\n\n\n\n\n\nMar 7, 2023\n\n\nPham Nguyen Hung\n\n\n\n\n\n\n\n\nGraph\n\n\n\n\n\nGraph\n\n\n\n\n\n\nFeb 10, 2023\n\n\nPham Nguyen Hung\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/graph/index.html",
    "href": "posts/graph/index.html",
    "title": "Graph",
    "section": "",
    "text": "Firstly, See About page."
  },
  {
    "objectID": "posts/graph/index.html#definitions",
    "href": "posts/graph/index.html#definitions",
    "title": "Graph",
    "section": "Definitions:",
    "text": "Definitions:\n\nA nonlinear data structure consists of nodes connected by vertices.\nA graph can be undirected, directed, or weighted."
  },
  {
    "objectID": "posts/graph/index.html#disjoint-set",
    "href": "posts/graph/index.html#disjoint-set",
    "title": "Graph",
    "section": "Disjoint set:",
    "text": "Disjoint set:\nRepresented as a data structures in LeetCode’s terminology\nHelps to register the connectivity of a graph/network. Consists of two arrays:\n\nStore the node itself (represented by index)\nStore the parent/root vertex of the node\n\nThe problem of checking connectivity is reduced to the problem of checking whether two nodes have the same root node.\nThe disjoint set has two essential methods: find() and union(). find() : find the root node of a given vertex\n\nunion()\n\nunions two vertices and makes their root nodes the same\n\n\n\nInitialization:\n\nStart with creating an array with array[i]=i\nCan implement with emphasis on find() (Quick Find) or union() (Quick Union)\n\n\n\nQuick Find:\nInstead of storing the parent node, the array will store the root node straight-away. This makes for a quick find() but slower union() as we need to search the entire array.\n\n# UnionFind class\nclass UnionFind:\n    def __init__(self, size):\n        self.root = [i for i in range(size)]\n\n    def find(self, x):\n        return self.root[x]\n        \n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            for i in range(len(self.root)):\n                if self.root[i] == rootY:\n                    self.root[i] = rootX\n\n    def connected(self, x, y):\n        return self.find(x) == self.find(y)\n\n\n# Test Case\nuf = UnionFind(10)\n# 1-2-5-6-7 3-8-9 4\nuf.union(1, 2)\nuf.union(2, 5)\nuf.union(5, 6)\nuf.union(6, 7)\nuf.union(3, 8)\nuf.union(8, 9)\nprint(uf.connected(1, 5))  # true\nprint(uf.connected(5, 7))  # true\nprint(uf.connected(4, 9))  # false\n# 1-2-5-6-7 3-8-9-4\nuf.union(9, 4)\nprint(uf.connected(4, 9))  # true\n\nTrue\nTrue\nFalse\nTrue\n\n\n\nTime Complexity:\n\n\n\n\nUnion-Find Constructor\nFind\nUnion\nConnected\n\n\n\n\nTime Complexity\n\\(O(N)\\)\n\\(O(1)\\)\n\\(O(N)\\)\n\\(O(1)\\)\n\n\n\nThe Union-Find Constructor is 1-liner in Python but it takes linear time to initialize in the system. #### Space Complexity: \\(O(N)\\) to store each node.\n\n\n\nQuick Union:\nunion() stops at setting the root node of the child to the root node of the parent only. find() and connected() will need to traverse more to find the answer. The worst-case time complexity for each operation swells to \\(O(N)\\), but the overall efficiency goes up.\n\n# UnionFind class\nclass UnionFind:\n    def __init__(self, size):\n        self.root = [i for i in range(size)]\n\n    def find(self, x):\n        while x != self.root[x]:\n            x = self.root[x]\n        return x\n        \n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            self.root[rootY] = rootX\n\n    def connected(self, x, y):\n        return self.find(x) == self.find(y)\n\n\n# Test Case\nuf = UnionFind(10)\n# 1-2-5-6-7 3-8-9 4\nuf.union(1, 2)\nuf.union(2, 5)\nuf.union(5, 6)\nuf.union(6, 7)\nuf.union(3, 8)\nuf.union(8, 9)\nprint(uf.connected(1, 5))  # true\nprint(uf.connected(5, 7))  # true\nprint(uf.connected(4, 9))  # false\n# 1-2-5-6-7 3-8-9-4\nuf.union(9, 4)\nprint(uf.connected(4, 9))  # true\n\nTrue\nTrue\nFalse\nTrue\n\n\n\nTime Complexity:\n\n\n\n\nUnion-Find Constructor\nFind\nUnion\nConnected\n\n\n\n\nTime Complexity\n\\(O(N)\\)\n\\(O(N)\\)\n\\(O(N)\\)\n\\(O(N)\\)\n\n\n\nThe Union-Find Constructor is 1-liner in Python but it takes linear time to initialize in the system.\nNumber of operations to get to the root vertex will be H, where H is the height of the tree. In the worst case, H = N if the graph is a linked list.\n\n\nSpace Complexity:\n\\(O(N)\\) to store each node.\n\n\n\nOptimized Quick Union - Union by rank:\nFirst, observe that the smaller the height of the tree, the more efficient the algorithms run. So we will want to balance the tree as much as we can, but not to try too hard. One way to do so is union by rank. Rank here refers to the height of the vertex. When we union two vertices, instead of just picking the root node of one, we choose the root node of the vertex with a larger “rank”. We will merge the shorter tree under the taller tree and assign the root node of the taller tree as the root node for both vertices.\nThis is an optimization for Quick Union. To implement this, we need to make 2 changes:\n\nAdding an array rank to keep track of the rank of each vertex.\nModify the codes of union(). It is easy for the case of unequal rank. For the case of equal rank, we will assign one to the other (say, set root of Y to root of X) and increase the height of the other vertex (X’s height += 1).\n\n\n# UnionFind class\nclass UnionFind:\n    def __init__(self, size):\n        self.root = [i for i in range(size)]\n        self.rank = [1] * size\n\n    def find(self, x):\n        while x != self.root[x]:\n            x = self.root[x]\n        return x\n        \n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            if self.rank[rootX] > self.rank[rootY]:\n                self.root[rootY] = rootX\n            elif self.rank[rootX] < self.rank[rootY]:\n                self.root[rootX] = rootY\n            else:\n                self.root[rootY] = rootX\n                self.rank[rootX] += 1\n\n    def connected(self, x, y):\n        return self.find(x) == self.find(y)\n\n\n# Test Case\nuf = UnionFind(10)\n# 1-2-5-6-7 3-8-9 4\nuf.union(1, 2)\nuf.union(2, 5)\nuf.union(5, 6)\nuf.union(6, 7)\nuf.union(3, 8)\nuf.union(8, 9)\nprint(uf.connected(1, 5))  # true\nprint(uf.connected(5, 7))  # true\nprint(uf.connected(4, 9))  # false\n# 1-2-5-6-7 3-8-9-4\nuf.union(9, 4)\nprint(uf.connected(4, 9))  # true\n\nTrue\nTrue\nFalse\nTrue\n\n\n\nTime Complexity:\n\n\n\n\nUnion-Find Constructor\nFind\nUnion\nConnected\n\n\n\n\nTime Complexity\n\\(O(N)\\)\n\\(O(logN)\\)\n\\(O(logN)\\)\n\\(O(logN)\\)\n\n\n\n\nThe Union-Find Constructor is 1-liner in Python but it takes linear time to initialize in the system.\nTree height will be at most log(N) + 1 when we repeatedly union components of equal rank, so find() will take O(logN) in the case.\nunion() and connected() depends on find(), so they need O(logN) as well.\n\n\n\nSpace Complexity:\n\\(O(N)\\) to store the value and the rank of each node.\n\n\n\nOptimized Quick Find - Path Compression:\nAfter finding the root node, we update the parent node of all traversed elements to their root node. We implement this with recursion.\n\n# UnionFind class\nclass UnionFind:\n    def __init__(self, size):\n        self.root = [i for i in range(size)]\n\n    def find(self, x):\n        if x == self.root[x]:\n            return x\n        self.root[x] = self.find(self.root[x])\n        return self.root[x]\n        \n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            self.root[rootY] = rootX\n\n    def connected(self, x, y):\n        return self.find(x) == self.find(y)\n\n\n# Test Case\nuf = UnionFind(10)\n# 1-2-5-6-7 3-8-9 4\nuf.union(1, 2)\nuf.union(2, 5)\nuf.union(5, 6)\nuf.union(6, 7)\nuf.union(3, 8)\nuf.union(8, 9)\nprint(uf.connected(1, 5))  # true\nprint(uf.connected(5, 7))  # true\nprint(uf.connected(4, 9))  # false\n# 1-2-5-6-7 3-8-9-4\nuf.union(9, 4)\nprint(uf.connected(4, 9))  # true\n\nTrue\nTrue\nFalse\nTrue\n\n\n\nTime Complexity:\n\n\n\n\nUnion-Find Constructor\nFind\nUnion\nConnected\n\n\n\n\nTime Complexity\n\\(O(N)\\)\n\\(O(logN)\\)\n\\(O(logN)\\)\n\\(O(logN)\\)\n\n\n\n\nThe Union-Find Constructor is 1-liner in Python but it takes linear time to initialize in the system.\nThe worst-case call of find() will take O(N), but it will take O(1) afterwards. Average out, it takes O(logN) time to perform.\nunion() and connected() depends on find(), so they need O(logN) as well.\n\n\n\nSpace Complexity:\n\\(O(N)\\) to store the value and the rank of each node.\n\n\n\nFinal disjoint set with Path Compression and Union by Rank:\n\n# UnionFind class\nclass UnionFind:\n    def __init__(self, size) -> None:\n        \"\"\"\n        Function to initialize the UnionFind class\n\n        :param size: the number of nodes in the set\n        :return: None\n        \"\"\"\n        self.root = [i for i in range(size)]\n        self.rank = [1]*size\n    \n    def find(self, node):\n        \"\"\"\n        Function to return the root of a node. Recursively\n        modify the parent node if it is not yet the root\n\n        :param node: the node to search root for\\\n        :return: the root node\n        \"\"\"\n        if node == self.root[node]:\n            return node\n        # Parent node is not itself and possibly not the\n        # root node\n\n        # Set the root of node to the root of the parent node\n        # of node\n        self.root[node] = self.find(self.root[node])\n        return self.root[node]\n\n    def union(self, node1, node2):\n        root1 = self.find(node1)\n        root2 = self.find(node2)\n        # Do nothing if the two nodes are already connected\n        # Set the root of both nodes to the root of the node\n        # with heigher rank (height)\n        # In case of equal rank, set to the root of one node\n        # and increase the rank of that node\n        if root1 != root2:\n            if self.rank[root1] > self.rank[root2]:\n                self.root[root2] = root1\n            elif self.rank[root1] < self.rank[root2]:\n                self.root[root1] = root2\n            else:\n                self.root[root2] = root1\n                self.rank[root1] += 1\n    \n    def connected(self, node1, node2):\n        return self.find(node1) == self.find(node2)\n            \n\n# Test Case\nuf = UnionFind(10)\n# 1-2-5-6-7 3-8-9 4\nuf.union(1, 2)\nuf.union(2, 5)\nuf.union(5, 6)\nuf.union(6, 7)\nuf.union(3, 8)\nuf.union(8, 9)\nprint(uf.connected(1, 5))  # true\nprint(uf.connected(5, 7))  # true\nprint(uf.connected(4, 9))  # false\n# 1-2-5-6-7 3-8-9-4\nuf.union(9, 4)\nprint(uf.connected(4, 9))  # true\n\nTrue\nTrue\nFalse\nTrue\n\n\n\nTime Complexity:\n\n\n\n\n\n\n\n\n\n\n\nUnion-Find Constructor\nFind\nUnion\nConnected\n\n\n\n\nTime Complexity\n\\(O(N)\\)\n\\(O(\\alpha(N))\\)\n\\(O(\\alpha(N))\\)\n\\(O(\\alpha(N))\\)\n\n\n\n\\(\\alpha(N)\\) is the inverse Ackermann function, which is \\(O(1)\\) on average.\n\n\nSpace Complexity:\n\\(O(N)\\) to store the value and the rank of each node.\n\n\n\nProblems\n\n1. Number of provinces\nThe basic problem applying the disjoint set approach. A province is essentially a network, and two provinces are two disconnected networks. We just need to keep track of the number of provinces when we perform union.\n# UnionFind class\nclass UnionFind:\n    def __init__(self, size):\n        self.root = [i for i in range(size)]\n        # Use a rank array to record the height of each vertex, i.e., the \"rank\" of each vertex.\n        # The initial \"rank\" of each vertex is 1, because each of them is\n        # a standalone vertex with no connection to other vertices.\n        self.rank = [1] * size\n        self.count = size\n\n    # The find function here is the same as that in the disjoint set with path compression.\n    def find(self, x):\n        if x == self.root[x]:\n            return x\n        self.root[x] = self.find(self.root[x])\n        return self.root[x]\n\n    # The union function with union by rank\n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            if self.rank[rootX] > self.rank[rootY]:\n                self.root[rootY] = rootX\n            elif self.rank[rootX] < self.rank[rootY]:\n                self.root[rootX] = rootY\n            else:\n                self.root[rootY] = rootX\n                self.rank[rootX] += 1\n            self.count -= 1\n\n    def getCount(self):\n        return self.count\n# The base problem for the whole class\n# Number of provinces are the number of disjoint sets left after performing all unions.\n# To achieve the goal, in addition to performing union-find, one also needs to take \n# care of the counting, which could be easily handled by deducting the number of nodes\n# after every union. \nclass Solution:\n    def findCircleNum(self, isConnected: list[list[int]]) -> int:\n        if not isConnected or len(isConnected) == 0:\n            return 0\n        n = len(isConnected)\n        uf = UnionFind(n)\n        for row in range(n):\n            for col in range(row + 1, n):\n                if isConnected[row][col] == 1:\n                    uf.union(row, col)\n        return uf.getCount()\n\n\n2. Number of Connected Components in an Undirected Graph\nEssentially the Number of Provinces problem. For this one, I tried not defining a separate UnionFind class but just the find() and union() functions.\nclass Solution:\n    def countComponents(self, n: int, edges: List[List[int]]) -> int:\n        rank = [1] * n\n        root = [i for i in range(n)]\n        \n        def find(x):\n            if x == root[x]:\n                return x\n            root[x] = find(root[x])\n            return root[x]\n        \n        def union(x, y):\n            # Declare n nonlocal to update n right in the union function\n            nonlocal n\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                if rank[rootX] > rank[rootY]:\n                    root[rootY] = rootX\n                elif rank[rootX] < rank[rootY]:\n                    root[rootX] = rootY\n                else:\n                    root[rootY] = rootX\n                    rank[rootX] += 1\n                n -= 1\n        \n        for edge in edges:\n            union(edge[0], edge[1])\n        \n        return n\n\n\n3. Graph Valid Tree\nA tree means that:\n\nNumber of edges provided must be at least the number of nodes - 1\nThere is no cycle.\n\nWe will use properties 1. to quickly rule out cases and 2. to implement the general algorithm. Property 2. is satisfied if we do not encounter two nodes with the same root when we perform the union operation; when we encounter such a case, we can return False immediately.\nclass Solution:\n    def validTree(self, n: int, edges: list[list[int]]) -> bool:\n        # write your code here\n        # Check the number of provinces\n        # False if more than 1\n        if len(edges) < n - 1:\n            return False\n        uf = UnionFind(n)\n        for A, B in edges:\n            if not uf.union(A, B):\n                return False\n        return True\n\n\n4. The Earliest Moment When Everyone Become Friends\nA.k.a the earliest moment the number of provinces goes to 1. If after performing all union operations, the number of provinces is larger than 1, we return -1\nfrom typing import List\n\nclass Solution:\n    def earliestAcq(self, logs: List[List[int]], n: int) -> int:\n        logs.sort()\n        root = [i for i in range(n)]\n        rank = [1] * n\n\n        def find(x):\n            if x == root[x]:\n                return x\n            root[x] = find(root[x])\n            return root[x]\n        \n        def union(x, y):\n            nonlocal n\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                if rank[rootX] > rank[rootY]:\n                    root[rootY] = rootX\n                elif rank[rootX] < rank[rootY]:\n                    root[rootX] = rootY\n                else:\n                    root[rootY] = rootX\n                    rank[rootX] += 1\n                n -= 1\n        \n        for timestamp, x, y in logs:\n            union(x, y)\n            if n == 1:\n                return timestamp\n                \n        return -1\n\n\n5. Smallest string with swaps:\nThe intuition here is recognizing that when the connected nindices form a graph that enable the corresponding characters to move around at will. THis means that we need to partition the indices into disjoint sets and sort within each set before joining them together to form the result.\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        length = component = len(s)\n        root = [i for i in range(length)]\n        rank = [1] * length\n\n        def find(x):\n            if x == root[x]:\n                return x\n            root[x] = find(root[x])\n            return root[x]\n        \n        def union(x, y):\n            nonlocal component\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                if rank[rootX] > rank[rootY]:\n                    root[rootY] = rootX\n                elif rank[rootX] < rank[rootY]:\n                    root[rootX] = rootY\n                else:\n                    root[rootY] = rootX\n                    rank[rootX] += 1\n                component -= 1\n        for pair in pairs:\n            union(pair[0], pair[1])\n        \n        # Easy case where every character is connected\n        if component == 1:\n            return ''.join(sorted(s))\n        \n        # General case\n        # We can only swap the the connected characters\n        listS = list(s)\n        copyListS = listS[:]\n        rootDict = {}\n        for i in range(length):\n            rootI = find(i)\n            if rootI in rootDict:\n                rootDict[rootI].append(i) # Ensure the nodes assoc. with a key is already sorted\n            else:\n                rootDict[rootI] = [i]\n\n        for connections in rootDict.values():\n            sortedConnections = sorted(connections, key = lambda x:ord(s[x]))\n            for i in range(len(connections)):\n                copyListS[connections[i]] = listS[sortedConnections[i]] \n        \n        return ''.join(copyListS)"
  },
  {
    "objectID": "posts/linked_list/index.html",
    "href": "posts/linked_list/index.html",
    "title": "Linked List",
    "section": "",
    "text": "Firstly, See About page."
  },
  {
    "objectID": "posts/linked_list/index.html#definitions",
    "href": "posts/linked_list/index.html#definitions",
    "title": "Linked List",
    "section": "Definitions:",
    "text": "Definitions:\n\nA nonlinear data structure consists of nodes with pointers to the next nodes.\nA linked list can be singly-linked, or doubly-linked, with just head pointer or together with tail pointer.\nFor LeetCode, a singly-linked list with head pointer is usually given.\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nMay fall under many patterns, such as fast and slow pointers."
  },
  {
    "objectID": "posts/linked_list/index.html#problems",
    "href": "posts/linked_list/index.html#problems",
    "title": "Linked List",
    "section": "Problems:",
    "text": "Problems:\n\n1. Reverse Linked List\nThe introductory problem to using the three pointers - pre, cur, and nex to keep track of the node in the list. Can be used to solve a sub-problem in the future.\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # Edge case:\n        if head is None or head.next is None:\n            return head\n        \n        # General case:\n        pre, cur, nex = None, head, head.next\n        while nex:\n            cur.next = pre\n            pre = cur\n            cur = nex\n            nex = nex.next\n        cur.next = pre\n        return cur\n\n\n2. Merge Two Sorted Lists\nChoose a new linked list. Move the two head pointers down the two lists, compare the nodes, and splice them accordingly.\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        # Edge case\n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        # General case\n        # Most straightforward way is to create a new linked list\n        # Utilize the sentinel head trick here\n        dummy = ListNode()\n        head = dummy\n\n        # One list will reach the end before the other, so it is divided into 2 steps:\n        # 1. Compare and splice the nodes in the two list\n        # 2. Add the rest of one list to the end of the result.\n        while list1 and list2:\n            if list1.val <= list2.val:\n                head.next = list1\n                list1 = list1.next\n            else:\n                head.next = list2\n                list2 = list2.next\n            head = head.next\n        \n        if list1:\n            head.next = list1\n        elif list2:\n            head.next = list2\n        \n        return dummy.next\n\n\n3. Linked List Cycle\nThe introductory fast and slow pointers problem. Because there is a loop, the fast and slow pointers are bound to meet with each other somewhere.\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        # Edge case\n        if head is None or head.next is None:\n            return False\n        \n        # General case\n        fast = slow = head\n        while fast.next and fast.next.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                return True\n        return False\n\n\n4. Remove Nth Node From End of List\nThe idea is to initialize two fast and slow pointers, but started at different positions while moving at the same speed. We want that when the fast pointer hits the end, the slow pointer is at the node before the to-be-removed node to rearrange the connection.\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        # Edge case\n        if head.next is None:\n            return\n        \n        # General case\n        # Fast and slow pointer\n        slow = fast = head\n        for _ in range(n+1):\n            if fast:\n                fast = fast.next\n            else:\n            # If fast pointer is already None before the end, there is just one\n            # case and it is the head needs removing, so we return the next element\n                return head.next\n        # If not, we start to move the slow and fast pointers to the end.\n        while fast:\n            slow, fast = slow.next, fast.next\n        \n        slow.next = slow.next.next\n        \n        return head\n\n\n5. Reorder List\nThe task can be divided into 3 parts:\n\nDivide the original list into 2.\nReverse the second half.\nMerge the two halves.\n\nHere we saw for the first time all the problems above come together into one problem. Here you see that I turned the second part into another hidden method within the Solution class. This is one way to do it. Another is to define the function within the function (nested function), which you will see many Python LeetCoders do. These two methods are equivalent in solving LeetCode problems. For outside world, I think that my current method is more appreciated, as of here.\nclass Solution:\n    def _reverseList(self, head: ListNode):\n        pre, cur, nex = None, head, head.next\n        while nex:\n            cur.next = pre\n            pre = cur\n            cur = nex\n            nex = nex.next\n        cur.next = pre\n        return cur\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        \"\"\"\n        Do not return anything, modify head in-place instead.\n        \"\"\"\n        # Edge case:\n        if head.next is None or head.next.next is None:\n            return\n        \n        # General case:\n        fast = slow = temp1 = temp2 = head\n        while fast.next and fast.next.next:\n            fast = fast.next.next\n            slow = slow.next\n        temp2 = slow.next\n        slow.next = None\n        del slow, fast\n        temp2 = self._reverseList(temp2)\n        nex1, nex2 = temp1.next, temp2.next\n        while nex2:\n            temp1.next = temp2\n            temp2.next = nex1\n            temp1, temp2 = nex1, nex2\n            nex1, nex2 = nex1.next, nex2.next\n        temp1.next = temp2\n        if nex1:\n            temp2.next = nex1"
  },
  {
    "objectID": "posts/linked_list/index.html#general-trick",
    "href": "posts/linked_list/index.html#general-trick",
    "title": "Linked List",
    "section": "General trick:",
    "text": "General trick:\n\n1. Sentinel head (also tail):\nWe create a dummy head first, modify everything after, and then return the actual head with dummy.next\ndummy = ListNode(None)\nhead = dummy\n# Do a lot of stuff with head\nreturn dummy.next\nThis is useful as we can use the head as a pointer to traverse the linked list while still need to return the head of the linked list in result."
  }
]