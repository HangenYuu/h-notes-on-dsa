[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog\nThis blog is mostly for my own study of data structures and algorithms and LeetCode questions. Therefore, it lacks the normal structure of a study resource for audience, especially for the LeetCode questions mentioned. There will be no problem statements, constraints, etc., only notes on intuition, approach, and code solutions with comments. Please open the corresponding LeetCode/LintCode questions while reading."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "H’s notes on Data Structuress and Algorithms",
    "section": "",
    "text": "Binary search\n\n\n\n\n\nBinary search\n\n\n\n\n\n\nMay 22, 2023\n\n\nPham Nguyen Hung\n\n\n\n\n\n\n  \n\n\n\n\nFast and slow pointers\n\n\n\n\n\nFast and slow pointers\n\n\n\n\n\n\nMay 22, 2023\n\n\nPham Nguyen Hung\n\n\n\n\n\n\n  \n\n\n\n\nLinked List\n\n\n\n\n\nLinked List\n\n\n\n\n\n\nMay 22, 2023\n\n\nPham Nguyen Hung\n\n\n\n\n\n\n  \n\n\n\n\nSliding window\n\n\n\n\n\nA variation of two pointers\n\n\n\n\n\n\nMay 22, 2023\n\n\nPham Nguyen Hung\n\n\n\n\n\n\n  \n\n\n\n\nStack\n\n\n\n\n\nStack\n\n\n\n\n\n\nMay 22, 2023\n\n\nPham Nguyen Hung\n\n\n\n\n\n\n  \n\n\n\n\nTwo pointers\n\n\n\n\n\nTwo pointers\n\n\n\n\n\n\nMay 22, 2023\n\n\nPham Nguyen Hung\n\n\n\n\n\n\n  \n\n\n\n\nArray\n\n\n\n\n\nArray\n\n\n\n\n\n\nMay 22, 2023\n\n\nPham Nguyen Hung\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/array/index.html",
    "href": "posts/array/index.html",
    "title": "Array",
    "section": "",
    "text": "Firstly, See About page."
  },
  {
    "objectID": "posts/array/index.html#definition",
    "href": "posts/array/index.html#definition",
    "title": "Array",
    "section": "Definition:",
    "text": "Definition:\nThe easiest, linear data structure, consisting of elements stored in contiguous memory slots. Elements are access by index, usually a number. The dictionary, or HashMap is a related data structure, consisting of key-value pairs that will be used in dealing array question."
  },
  {
    "objectID": "posts/array/index.html#problem",
    "href": "posts/array/index.html#problem",
    "title": "Array",
    "section": "Problem:",
    "text": "Problem:\n\n1. Two Sum:\nThe basic of basic problem, the first problem everybody encounters when he/she starts LeetCoding.\n\nIntuition\n\nTraversing the list seems like the most logical thing to do. The brute-force way is to check every pair of numbers. The time complexity is O(n^2). To optimize this, it is better to store the information we have already encountered when we traverse the list. We need to use a data structure that supports fast searching - HashMap. Either way works, but the HashMap can be used for storing the index of the element as well. If we store an element as the key and the index as the value, we can quickly search and return the indices.\n\n\nAlgorithm\n\nThe algorithm can be described as:\n\nTraverse the array from the beginning.\nStore the element encountered in a set/dictionary.\nCheck if the sum - element is in the dictionary.\nReturn the indices.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): Traversing the whole list once.\nSpace complexity:  \\(O(n)\\): In the worst case, we will have a dictionary with a size equal to the array.\n\n\n\nCode\nfrom collections import defaultdict\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        numsDict = defaultdict(int)\n        for ind, num in enumerate(nums):\n            if target-num in numsDict:\n                return [ind, numsDict[target-num]]\n            numsDict[num] = ind\n\n\n\n2. Contains Duplicate\n\nIntuition\n\nAgain, traverse the array, storing information about what we have encountered. This time, we only need to store the element itself, so a HashSet suffices.\n\n\nAlgorithm\n\n\nTraverse the array.\nCheck if the current element is in the HashSet. If it is, return True for duplicate.\nIf we reach the end of the array, return False for no duplicate.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): Traversing the whole list once.\nSpace complexity:  \\(O(n)\\): In the worst case, we will have a set with a size equal to the array.\n\n\n\nCode\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -&gt; bool:\n        numSet = set()\n        for num in nums:\n            if num in numSet:\n                return True\n            numSet.add(num)\n        return False\n\n\n\n3. Valid Anagram:\n\nIntuition\n\nAgain, traverse the array, storing information about what we have encountered. This time, we only need to store the element itself, so a HashSet suffices.\n\n\nAlgorithm\n\n\nTraverse the array.\nCheck if the current element is in the HashSet. If it is, return True for duplicate.\nIf we reach the end of the array, return False for no duplicate.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): Traversing the whole list once.\nSpace complexity:  \\(O(n)\\): In the worst case, we will have a set with a size equal to the array.\n\n\n\nCode\nfrom collections import defaultdict\nclass Solution:\n    def isAnagram(self, s: str, t: str) -&gt; bool:\n        if len(s) != len(t):\n            return False\n        hashS, hashT = defaultdict(int), defaultdict(int)\n        for index in range(len(s)):\n            hashS[s[index]] += 1\n            hashT[t[index]] += 1\n        return hashS == hashT\n\n\n\n4. Majority Element\n\nIntuition\n\nThere are many approaches to the problem. The simplest way except brute-force the whole thing is to use a HashMap to count the number of occurences of each element (in Python can be done faster with collections.Counter). The solution provided is to deal with the follow-up question of linear time with \\(O(1)\\) memory.\n\n\nAlgorithm\n\nThis is a named algorithm: Boyer-Moore Voting Algorithm. The procedure is this: while we traverse the array, if we choose the first element as a candidate and consider three things:\n\nAn encounter with the same element a vote for the candidate\nAn encounter with a difference element a vote against the candidate\nChange the candidate to the current element if it is different than the candidate and the vote for the candidate has become 0\n\nthen at the end, we should be left with the candidate.\nThis is because the majority element will occur more than n//2 times with n the length of the array. Because of this, the majority element will be the only possible candidate with a positive vote at the end.\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): We need to traverse the array once.\nSpace complexity:  \\(O(1)\\): We only need to keep track of the count and the candidate, which requires constant memory.\n\n\n\nCode\nclass Solution:\n    def majorityElement(self, nums):\n        count = 0\n        candidate = None\n\n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n\n        return candidate\n\n\n\n5. Group Anagrams\n\nIntuition\nFrom Valid Anagram, we know that one word is an anagram of another if character frequencies are the same. We can check everything in one go with a dictionary. The key information is lowercase letter only. This means that character frequency can be capture in a tuple of 26 number, each one the number of character a, b, etc. in the word. We can append each word to the correct key in the dictionary. Afterwards, we simply return the values of the dictionary.\n\n\nAlgorithm\n\nInitialize a dictionary, better with Python defaultdict.\nIterate the list of words. For each word, initialize an array of 26 0s and increment the correct count for each character. ord() is useful in this case.\nAppend the word to the value array of the correct key.\nReturn the values of the dictionary.\n\n\n\nComplexity\n\nTime complexity:  \\(O(nk)\\): We need to traverse the array once. \\(k\\) is the maximum length of a string in the array.\nSpace complexity:  \\(O(nk)\\): The information stored in the dictionary.\n\n\n\nCode\nfrom collections import defaultdict\nclass Solution:\n    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:\n        countDict = defaultdict(list)\n        for s in strs:\n            count = [0] * 26\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n            countDict[tuple(count)].append(s)\n        return countDict.values()\n\n\n\n6. Top K Frequent Elements\n\nIntuition\nTo satisfy the \\(O(nlogn)\\) time constraint, computer science students will think of Quickselect. If you know how to implement Quickselect, it’s fine.\nFor someone who doesn’t, the approach is to use a dictionary the frequency as the key, and the value an array of elements with that key. To return, we can just iterate the dictionary from the maximum value to the minimum, append the value to an array and return the k elements. #### Algorithm\n\nTake frequency count of the elements in the array, better with Python Counter\nInitialize a dictionary, better with Python defaultdict.\nIterate the array. Append each element to the value of the correct key.\nIterate the dictionary from the maximum value down for the top-k elements and return it.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): We need to traverse the array once and the dictionary once. Worst-case, the dictionary has the same size as the array.\nSpace complexity:  \\(O(n)\\): Worst-case, we will need to store triple the memory of the original array.\n\n\n\nCode\nfrom collections import defaultdict, Counter\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:\n        count = Counter(nums)\n        ans = defaultdict(list)\n        for num in count:\n            ans[count[num]].append(num)\n        top = max(ans)\n        res = []\n        for i in range(top,-1,-1):\n            res.extend(ans[i])\n        return res[:k]\nOptimized solution from NeetCode\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:\n        # Bucket Sort\n        countDict = {}\n        for i in nums:\n            countDict[i] = countDict.get(i, 0) + 1\n        freqList = [[] for i in range(len(nums))]\n        for num, count in countDict.items():\n            freqList[count-1].append(num)\n        res = []\n        for i in range(len(freqList) - 1, 0, -1):\n            for n in freqList[i]:\n                res.append(n)\n                if len(res) == k:\n                    return res\n\n\n\n7. Encode and Decode Strings\n\nIntuition\nThere are many approaches to this problem. My approach is the simplest: I will use an usual combination of character to insert between strings in the list. To minimize memory use, I choose a 3 combo: '*-*'. I reckon that I can get the work done with '*-', but '*-* is safer and cuter.\nA more seasoned programmer will give a more complex approach. He will use ':' to insert between, and inserting '::' when there is a ':'. This is a general method, which takes care of the case you need to impress the guys by showing that you can think generally, given that you may need to learn another language at the company. But in Python, simpler is better - it is just an one-liner with fast, optimized method for both functions. But of course, it is not so impressive, making you look so dependent on Python.\nNeetCode has a middle approach - Use the length and '#' to insert before each character. This is much better.\n\n\nAlgorithm\nOne-liner: Use built-in method .join() and .split() to do the heavy work.\nGeneral:\n\nEncode the string by concatenating the length + '#' + the string into a big one and return.\nDecode the string by creating a for loop and deal with phrases consequentially.\n\nExtract the character length of the next phrase from the string.\nUse slicing to get the phrase and append to the result list.\nMove on to the next position.\nReturn the result.\n\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): We need to traverse the array and string once for each.\nSpace complexity:  \\(O(1)\\): We will need to store some pointers for both functions.\n\n\n\nCode\nOne-liner\nclass Solution:\n    \"\"\"\n    @param: strs: a list of strings\n    @return: encodes a list of strings to a single string.\n    \"\"\"\n    def encode(self, strs):\n        # write your code here\n        return '*-*'.join(strs)\n\n    \"\"\"\n    @param: str: A string\n    @return: dcodes a single string to a list of strings\n    \"\"\"\n    def decode(self, str):\n        # write your code here\n        return str.split('*-*')\nOptimized NeetCode\nclass Solution:\n    \"\"\"\n    @param: strs: a list of strings\n    @return: encodes a list of strings to a single string.\n    \"\"\"\n\n    def encode(self, strs):\n        res = \"\"\n        for s in strs:\n            res += str(len(s)) + \"#\" + s\n        return res\n\n    \"\"\"\n    @param: s: A string\n    @return: decodes a single string to a list of strings\n    \"\"\"\n\n    def decode(self, s):\n        res, i = [], 0\n\n        while i &lt; len(s):\n            j = i\n            while s[j] != \"#\":\n                j += 1\n            length = int(s[i:j])\n            res.append(s[j + 1 : j + 1 + length])\n            i = j + 1 + length\n        return res\n\n\n\n8. Product of Array Except Self\n\nIntuiton\nThe trick is to use “prefix” and “postfix” arrays, respectively storing the product of all elements coming before and after the current values. These arrays have the properties of being able to be calculated iteratively in a for loop from the calculated value before. The answer is simply the element-wise product of the two arrays.\nTo get to the \\(O(1)\\) memory solution, it is about converting one array into just a pointer to cache the product.\n\n\n\nAlgorithm\n\nTraverse the array to calculate the prefix (postfix array).\nTraverse the array again to update the postfix product and also the result.\nReturn the result.\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): We need to traverse the original array twice.\nSpace complexity:  \\(O(1)\\): We will need to store the postfix product while calculating.\n\n\n\nCode\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:\n        # To achieve O(1) space, will need to perform the multiplication \n        # directly on the prefix array\n        # postfix array needs to become just a pointer to the cached product \n        lenNum = len(nums)\n        prefix, postfix = [1] * lenNum, 1\n        for i in range(1, lenNum):\n            prefix[i] = prefix[i-1]*nums[i-1]\n        for i in range(lenNum-1, -1, -1):\n            prefix[i] *= postfix\n            postfix *= nums[i]\n        return prefix\n\n\n\n9. Valid Sudoku\n\nIntuiton\nThe nested for loop to check every element is inevitable. The trick is to realize that the box can be arranged and accessed with modulo 3.\n\n\n\nAlgorithm\n\nInitialized rows, cols, boxes to keep track of the respective factor. The most elegant way to do this in Python is with collections.defaultdict(set)\nTraverse the board with a nested for loop and update the respective factor.\nReturn False whenever a condition is violated, or True if the for loop executes successfully.\n\n\nComplexity\n\nTime complexity:  \\(O(n^2)\\): We need to traverse the original array with a nested for loop. Of course, if we are dealing with a standard Sudoku every time then it is \\(O(1)\\).\nSpace complexity:  \\(O(n)\\): We will need to store 3 dictionaries with worse case the same size as the board.\n\n\n\nCode\nfrom collections import defaultdict\n\nclass Solution:\n    def isValidSudoku(self, board: List[List[str]]) -&gt; bool:\n        rows, cols, boxes = defaultdict(set), defaultdict(set), defaultdict(set)\n        for row in range(9):\n            for col in range(9):\n                cur = board[row][col]\n                if cur != '.':\n                    if (cur in rows[row] or\n                        cur in cols[col] or\n                        cur in boxes[(row//3, col//3)]):\n                        return False\n                    rows[row].add(cur)\n                    cols[col].add(cur)\n                    boxes[(row//3, col//3)].add(cur)\n        return True\n\n\n\n10. Longest Consecutive Sequence\n\nIntuiton\nWe need to perform a lot of searches and there is the possibility of duplicates. Hence, it is better if we convert the array to a set. We can also create safeguard by NOT counting the number in the sequence if the one preceding it is in the set.\n\n\nAlgorithm\n\nConvert the whole array into a set.\nTraverse the set. For each element, count and update the longest consecutive sequence if the one preceding it is not in the array.\nReturn the longest length.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): We need to traverse the original array once\nSpace complexity:  \\(O(n)\\): We will need to store a set with the same size as the array.\n\n\n\nCode\nclass Solution:\n    def longestConsecutive(self, nums):\n        longest_streak = 0\n        num_set = set(nums)\n\n        for num in num_set:\n            if num - 1 not in num_set:\n                current_num = num\n                current_streak = 1\n\n                while current_num + 1 in num_set:\n                    current_num += 1\n                    current_streak += 1\n\n                longest_streak = max(longest_streak, current_streak)\n\n        return longest_streak"
  },
  {
    "objectID": "posts/binary_search/index.html",
    "href": "posts/binary_search/index.html",
    "title": "Binary search",
    "section": "",
    "text": "Firstly, See About page."
  },
  {
    "objectID": "posts/binary_search/index.html#definitions",
    "href": "posts/binary_search/index.html#definitions",
    "title": "Binary search",
    "section": "Definitions:",
    "text": "Definitions:\nIn a sorted array, there exists a faster way to search for a specific element than visiting each element. The intuition is if we find an element that is smaller than expected, all of the elements before it are also smaller and can be discarded from the search and likewise if it is larger. The optimal way to take advantage of this property is striking in the middle every time, hence the name binary search."
  },
  {
    "objectID": "posts/binary_search/index.html#problem",
    "href": "posts/binary_search/index.html#problem",
    "title": "Binary search",
    "section": "Problem",
    "text": "Problem\n\n1. Binary serach\n\nIntuition\n\nThe basic problem of binary search. It basically asks you to implement it.\n\n\nAlgorithm\n\n\nInitialize two pointers - start and end.\nTraverse the array from both ends.\nCalculate middle = (start + end)//2 and compare array[middle] with the target.\nIf we found the target, return middle. If we are smaller, move start to middle. If we are larger, move end to middle.\nIf we reach the end, return -1 as we do not find the target.\n\n\n\nComplexity\n\nTime complexity:  \\(O(logn)\\): We are cutting the array in half repeatedly, so it takes just \\(logn\\) to search.\nSpace complexity:  \\(O(1)\\): Pointers are essentially integers.\n\n\n\nCode\nclass Solution:\n    def search(self, nums: List[int], target: int) -&gt; int:\n        # Edge case\n        if nums[0] &gt; target or nums[-1] &lt; target:\n            return -1\n        \n        # General case\n        if nums[0] == target:\n            return 0\n        if nums[-1] == target:\n            return len(nums) - 1\n        start, end = 0, len(nums) - 1\n        while start &lt;= end:\n            mid = (start + end)//2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] &lt; target:\n                start = mid + 1\n            else:\n                end = mid - 1\n        \n        return -1\n\n\n\n2. First Bad Version\n\nIntuition\n\nFor any call isBadVersion(version), if the version is good, it means that the first bad version will be a later version; if the version is bad, it means that the first bad version might be an older version. And given the version comes in non-decreasing order, that sounds exactly like a binary search problem. Notice the italic will be and might be - it will affect the way we implement the algorithm.\n\n\nAlgorithm\n\n\nInitialize two pointers - first and last or whatever to the first and the last version, denoted by numbers.\nThe terminating condition for this specific implementation is first == last, so the loop condition is while first &lt; last.\nWe will check the mid version. If it is bad, we will shift last to mid. If it is good, we will shift first to mid + 1.\nReturn first (or last - does not matter) when the loop terminates. Cannot return mid here as the variable does not exist outside the loop. You can define it so, but there’s no need to.\n\n\n\nComplexity\n\nTime complexity:  \\(O(log(n))\\): The default time complexity of binary search.\nSpace complexity:  \\(O(1)\\): Pointers are essentially integers.\n\n\n\nCode\n# The isBadVersion API is already defined for you.\n# def isBadVersion(version: int) -&gt; bool:\n\nclass Solution:\n    def firstBadVersion(self, n: int) -&gt; int:\n        low, high = 1, n\n        while low &lt; high:\n            mid = (low+high)//2\n            if isBadVersion(mid):\n                high = mid\n            else:\n                low = mid + 1\n        return low #high\n\n\n\n3. Search a 2D Matrix\n\nIntuition\n\nThe matrix is sorted + time complexity requirement of \\(O(log(m*n))\\) → a binary search problem where we need to do binary search two times.\nThe first binary search is for the row target is in. The condition to satisfy is start &lt; target &lt; end. We can move start and end if the end of the row is smaller than target and the start of the row is larger than target, respectively.\nThe next binary search within the row is trivial.\n\n\nAlgorithm\n\n\nInitialize pointers. We need to store the index of the row so initialize an extra one.\nPerform binary search based on conditions above to find the row.\nReinitialize pointers.\nPerform a normal binary search within the row and return result accordingly.\n\n\n\nComplexity\n\nTime complexity:  \\(O(log(m*n))\\): Two binary searches were performed, one to find the row, and one within the row.\nSpace complexity:  \\(O(1)\\): We only need to store pointers.\n\n\n\nCode\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:\n        # O(log(m*n)) = O(logm) + O(logn)\n        start, mid, end = 0, 0, len(matrix)-1\n        while start &lt;= end:\n            mid = (start+end)//2\n            if matrix[mid][0] == target or matrix[mid][-1] == target:\n                return True\n            elif matrix[mid][0] &lt; target &lt; matrix[mid][-1]:\n                break\n            elif matrix[mid][-1] &lt; target:\n                start = mid + 1\n            elif matrix[mid][0] &gt; target:\n                end = mid - 1\n        # Return False immediately if start &gt; end\n        # as it signifies no valid row found\n        if start &gt; end:\n            return False\n        start, end = 0, len(matrix[0]) - 1\n        while start &lt;= end:\n            middle = (start+end)//2\n            if matrix[mid][middle] == target:\n                return True\n            elif matrix[mid][middle] &lt; target:\n                start = middle + 1\n            else:\n                end = middle - 1\n        return False\n\n\n\n4. Koko Eating Bananas\n\nIntuition\n\nThe problem is discovering what we are supposed to perform binary search on. For this purpose, we need to lean on the brute-force method. So the brute-force method is iterating all possible values of k from 1 to max(piles. The rest is realizing that this is a sorted array, hence we can perform binary search on that.\n\n\nAlgorithm\n\n\nInitialize pointers and a variable to store the result e.g., res.\nIterate the array from 1 to max(piles) for k.\nAt each value, calculate the hours taken for such k. If the hourse is smaller or equal to h, it is a likely candidate so we update the res if necessary and update the right pointer. Else, we update the left pointer.\nReturn res at the end\n\n\n\nComplexity\n\nTime complexity:  \\(O(log(max(piles))*len(piles))\\): For each iteration of binary search, we need to calculate the hours, which requires iterating through the array once each time.\nSpace complexity:  \\(O(1)\\): We need to store a bunch of variables.\n\n\n\nCode\nfrom math import ceil\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -&gt; int:\n        # Easy case:\n        if len(piles)==h:\n            return max(piles)\n\n        # General cases:\n        left, right = 1, max(piles)\n        res = right\n        while left &lt;= right:\n            k = (left+right)//2\n            hours = 0\n            for pile in piles:\n                hours += ceil(pile/k)\n            if hours &lt;= h:\n                right = k - 1\n                res = min(res, k)\n            else:\n                left = k + 1\n        \n        return res\n\n\n\n5. Median of Two Sorted Arrays\n\nIntuition\n\nThe result median is the element that has roughly \\((m+n)//2\\) elements to both sides. We can get to this element by partitioning a certain number of elements from each array that sums up to \\((m+n)//2\\). The median can then be selected or calculated from the last element in the left subarray and the first element in the right subarray of each array.\nThe good thing is the safeguard that NeetCode came up with. The index chosen can be out of bound. For such case, we can set the variable to be \\(-\\infty\\) for the left variable or \\(\\infty\\) for the right variable, as we only need to care for the right minimum and left maximum.\n\n\nAlgorithm\n\n\nInitialize variables - the arrays, total length, half point.\nPerform binary search on one array by selecting the left half-array every time (all elements up to index (start+end)//2) and take the rest from the other array. Pick out the last left element and the first right element.\nIf all the left are smaller than the other right, calculate the median. Increment the pointer to decrease/increase the number of elements taken from an array if the last left is smaller than the first right correspondingly.\n\n\n\nComplexity\n\nTime complexity:  \\(O(log(m+n))\\): We essentially iterate a concatenated version of the two arrays.\nSpace complexity:  \\(O(n)\\): This implementation requires creating a copy of each array.\n\n\n\nCode\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:\n        A, B = nums1, nums2\n        total = len(A) + len(B)\n        half = total // 2\n        \n        if len(B) &lt; len(A):\n            A, B = B, A\n        \n        l, r = 0, len(A)-1\n        while True:\n            i = (l+r)//2\n            j = half - i -2\n\n            Aleft = A[i] if i &gt;= 0 else float(\"-infinity\")\n            Bleft = B[j] if j &gt;= 0 else float(\"-infinity\")\n            Aright = A[i+1] if (i+1) &lt; len(A) else float(\"infinity\")\n            Bright = B[j+1] if (j+1) &lt; len(B) else float(\"infinity\")\n\n            # partition is correct\n            if Aleft &lt;= Bright and Bleft &lt;= Aright:\n                if total % 2:\n                    return min(Aright, Bright)\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2\n            elif Aleft &gt; Bright:\n                r = i - 1\n            else:\n                l = i + 1\n\n\n\n6. Find the Duplicate Number\n\nIntuition\n\nThis can be solved with fast and slow pointers. However, there exists an interesting binary search solution. It has a worse time complexity, but it is interesting to see how the problem can be framed as a binary search problem.\nIn an array with \\(n+1\\) elements from \\(1\\) to \\(n\\), the number of elements smaller or equal than \\(k\\) is \\(k\\). However, if there is a duplicate, say \\(n\\), the number of elements smaller or equal than \\(k\\) is greater than \\(k\\), for all elements greater than or equal to \\(n\\). We can use this property to perform binary search on the range \\([1, n]\\), searching for the first element with the number of elements smaller or equal to it greater than itself.\n\n\nAlgorithm\n\n\nInitialize the left and right pointers.\nPerform binary search on the range \\([1, n]\\). At each iteration, calculate the number of elements smaller or equal to the middle element. If the number is greater than the middle element, we know the duplicate is in the left half. Else, we know the duplicate is in the right half.\nReturn the left pointer.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n \\log n)\\): At each iteration of the binary search, we need to iterate through the array to calculate the number of elements smaller or equal to the middle element.\nSpace complexity:  \\(O(1)\\): We only need to store pointers.\n\n\n\nCode\nUpdate: The solution cannot pass the time limit check on LeetCode. The solution is correct, but it is not efficient enough.\nclass Solution:\n    def findDuplicate(self, nums: List[int]) -&gt; int:\n        left, right = 1, len(nums)-1\n        while left &lt;= right:\n            mid = (left+right)//2\n            less = sum(1 for num in nums if num &lt;= mid)\n\n            if less &gt; mid:\n                right -= 1\n            else:\n                left += 1\n        \n        return left"
  },
  {
    "objectID": "posts/fast_and_slow_pointers/index.html",
    "href": "posts/fast_and_slow_pointers/index.html",
    "title": "Fast and slow pointers",
    "section": "",
    "text": "Firstly, See About page."
  },
  {
    "objectID": "posts/fast_and_slow_pointers/index.html#definitions",
    "href": "posts/fast_and_slow_pointers/index.html#definitions",
    "title": "Fast and slow pointers",
    "section": "Definitions",
    "text": "Definitions\nThis is not a data structure, but a pattern of coding interview questions. This is something passed down from languages with pointers such as C++ or Java. The idea is that we will traverse the array with two pointers simultaneously, one of them will be “faster” than the other, in the sense of headstart (start at a further location while moving at the same speed) or speed (the fast one move faster e.g., two steps at a time, while the slow one will move one step at a time while starting at the same locaiton). This pattern is very useful for solving problems related to linked lists or arrays. Also known as the Floyd’s “Hare and Tortoise Algorithm”."
  },
  {
    "objectID": "posts/fast_and_slow_pointers/index.html#problem",
    "href": "posts/fast_and_slow_pointers/index.html#problem",
    "title": "Fast and slow pointers",
    "section": "Problem",
    "text": "Problem\n\n1. Happy Number\n\nIntuition\n\nThe hint lies at the problem statement: it is either going to 1, or going into a loop. If there is a loop, fast and slow pointers should be used.\n\n\nAlgorithm\n\n\nInitialize the two pointers slow and fast to n and the helper function to calculate sum of square of digits (\\(SS\\)).\nAt each step, assign slow to the \\(SS\\) of itself and fast to the \\(SS\\) of \\(SS\\) of itself. We check and then return accordingly when we go into loop or encounter 1.\n\n\n\nComplexity\n\nTime complexity:  \\(O(\\log n)\\): The detailed analysis can be found here. The first solution with HashSet is helpful as it explains how can we rule out the third possibility that is not mentioned in the problem statement: the number increases infinitely. Simply, it will all goes down below 243. The \\(\\log\\) appears here because it is the cost of processing every unit of a number. The full term is \\(O(243 \\times 3 + \\log n+\\log \\log n+\\log \\log \\log n)... = O(\\log n)\\) but the \\(\\log\\) term dominates the sum. For our two pointers, the cost is \\(O(\\log n)\\) for each, but \\(2\\) is a constant so omitted.\nSpace complexity:  \\(O(1)\\): We only need to store pointers.\n\n\n\nCode\nclass Solution:\n    def isHappy(self, n: int) -&gt; bool:\n        if n == 1:\n            return True\n        slow = fast = n \n        \n        while True:\n            slow = self._sumOfSquare(slow)\n            fast = self._sumOfSquare(self._sumOfSquare(fast))\n            if slow == 1 or fast == 1:\n                return True\n            if slow == fast:\n                return False\n\n    def _sumOfSquare(self, n: int) -&gt; int:\n        result = 0\n        while n != 0:\n            result += (n % 10)**2\n            n //= 10\n        return result\n\n\n\n2. Linked List Cycle\nThe introductory fast and slow pointers problem. If there is a loop, the fast and slow pointers are bound to meet with each other somewhere.\n\nIntuition\n\nIf I am not told about the problem, I don’t think I can come up with the solution. This is something you have to know beforehand. But well, in an interview, you will be assessed on your ability to solve harder problems with this approach, so that is our real goal.\n\n\nAlgorithm\n\n\nInitialize the two pointers fast and slow to head.\nAt each step, assign fast to the next of the next of itself and slow to the next of itself. We check and then return accordingly when we go into loop i.e., the two pointers meet.\nIf we reach the end of the list, we return False.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): Both pointers traverse the list at least once.\nSpace complexity:  \\(O(1)\\): We only need to store pointers.\n\n\n\nCode\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -&gt; bool:\n        # Easy case\n        if head is None or head.next is None:\n            return False\n        \n        # General case\n        fast = slow = head\n        while fast.next and fast.next.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                return True\n        return False\n\n\n\n3. Remove Nth Node From End of List\nThe idea is to initialize two fast and slow pointers, but started at different positions while moving at the same speed. We want that when the fast pointer hits the end, the slow pointer is at the node before the to-be-removed node to rearrange the connection.\n\nIntuition\n\nThis is the second type of fast and slow pointers: they move at the same speed but start at different positions. The idea is that we want the fast pointer to hit the end of the list, while the slow pointer is at the node before the to-be-removed node. Then we can rearrange the connection.\n\n\nAlgorithm\n\n\nInitialize the two pointers fast and slow to head.\nMove the fast pointer n+1 steps ahead of the slow pointer.\nMove both pointers until the fast pointer hits the end of the list.\nRemove the node next of the slow pointer.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): Both pointers traverse the list at most once.\nSpace complexity:  \\(O(1)\\): We only need to store pointers.\n\n\n\nCode\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n        # Easy case\n        if head.next is None:\n            return\n        \n        # General case\n        # Fast and slow pointer\n        slow = fast = head\n        for _ in range(n+1):\n            if fast:\n                fast = fast.next\n            else:\n            # If fast pointer is already None before the end, there is just one\n            # case and it is the head needs removing, so we return the next element\n                return head.next\n        # If not, we start to move the slow and fast pointers to the end.\n        while fast:\n            slow, fast = slow.next, fast.next\n        \n        slow.next = slow.next.next\n        \n        return head\n\n\n\n4. Middle of the Linked List\n\nIntuition\n\nBecause the fast pointer is doubly faster than the slow, when the fast pointer hits the end, the slow pointer will be at the middle node.\n\n\nAlgorithm\n\n\nInitialize the two pointers fast and slow to head.\nMove the fast pointer 2 steps and the slow pointer 1 step at each iteration till termination.\nReturn the slow pointer or the node next to it.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): Both pointers traverse the list at most once.\nSpace complexity:  \\(O(1)\\): We only need to store pointers.\n\n\n\nCode\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        if head.next is None:\n            return head\n        slow, fast = head, head\n        while fast.next is not None and fast.next.next is not None:\n            slow = slow.next\n            fast = fast.next.next\n        if fast.next is not None:\n            slow = slow.next\n        return slow\n\n\n\n5. Circular Array Loop\n\nIntuition\n\nLet’s ignore the instruction to solve in \\(O(n)\\) time complexity for now (\\(O(1)\\) space complexity is achieved with pointers).\nFor every element, we need to check if it is a part of a cycle. If it is, we need to check if the cycle is valid. If it is, we return True. Otherwise, we continue to check the next element. A cycle is invalid if there exist elements with different signs in the cycle. This means that at least one product between a pair of elements is negative. The direction direction condition can be tracked with a variable, and the terminating condition can be signaled by setting the pointer to \\(-1\\). A cycle also needs to have more than one element. This means that an element with value divisible by the length of the array is invalid. This solution is \\(O(n^2)\\) time complexity, as we will have a nested loop each iterating through the array in the worst case.\nTo move on to the \\(O(n)\\) solution, we can keep track of the elements we have visited. The most straightforward is having an array or a HashMap, but it violates the \\(O(1)\\) space complexity. Hence, this means modifying the array in place into 0.\n\n\nAlgorithm\n\n\nInitialize the variable current_direction to None.\nIterate through the array. If the element is divisible by the length of the array, continue to the next element.\nIf the element is not divisible by the length of the array, set the current_direction to True if the element is positive, and False if the element is negative. Set the slow and fast pointers to the current index.\nWhile the two pointers have not met or terminating condition (pointer is \\(-1\\)), move the slow pointer one step and the fast pointer two steps, each time checking for the terminating condition. If the pointers are equal and both are not \\(-1\\), return True.\nReturn False at the end.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n^2)\\) or \\(O(n)\\): Depend on the implementation and condition whether we can modify the array in place.\nSpace complexity:  \\(O(1)\\): We only need to store pointers.\n\n\n\nCode\nclass Solution:\n    def circularArrayLoop(self, nums: List[int]) -&gt; bool:\n        current_direction = None\n        for i in range(len(nums)):\n            if not nums[i] % len(nums):\n                continue\n            current_direction = True if nums[i] &gt; 0 else False\n            slow = fast = i\n            while slow != fast or slow != -1 or fast != -1:\n                slow = self._one_step(nums, slow, current_direction)\n                if slow == -1:\n                    break\n                fast = self._one_step(nums, fast, current_direction)\n                if fast != -1:\n                    fast = self._one_step(nums, fast, current_direction)\n                \n                if fast == -1 or slow == fast:\n                    break\n                \n            if slow == fast and slow != -1:\n                return True\n        \n        return False\n\n    def _one_step(self, nums, current_index, current_direction):\n        next_direction = True if nums[current_index] &gt; 0 else False\n        if ((next_direction != current_direction) or \n            (not nums[current_index] % len(nums))):\n            return -1\n        next_step = (current_index + nums[current_index]) % len(nums)\n        return next_step\nOptimized \\(O(n)\\) version:\nclass Solution:\n    def circularArrayLoop(self, nums: List[int]) -&gt; bool:\n        if len(nums) &lt; 2:\n            return False\n        n = len(nums)\n        for i in range(n):\n            if nums[i] == 0:\n                continue\n            \n            slow, fast = i, (i + nums[i]) % n\n            while nums[i] * nums[fast] &gt; 0 and nums[i] * nums[(fast + nums[fast])%n] &gt; 0:\n                if slow == fast:\n                    if slow == (slow + nums[slow])%n:\n                        break\n                    return True\n                slow = (slow + nums[slow])%n\n                fast = (fast + nums[fast])%n\n                fast = (fast + nums[fast])%n\n\n            slow = i\n            sgn = nums[i]\n            while sgn * nums[slow] &gt; 0:\n                tmp = (slow + nums[slow])%n\n                nums[slow] = 0\n                slow = tmp\n        return False\n\n\n\n6. Find the Duplicate Number\n\nIntuition\n\nDirichlet’s principle will help you to prove that there must be a duplicate in the array. Next, because of the constraints of numbers from \\(1\\) to \\(n\\) inside an array of length \\(n+1\\), we can see that we can access every element of the array with the function nums[index]. This means that the array can be turned into a linked list, where the value is the index and the next pointer is the value of the element. In this linked list, the duplicate element creates a cycle, as there are at least two elements pointing to it, making it the entrance of a cycle.\n\nHowever, the problem is not Is there a cycle? but Where is the cycle?. In other words, we need to find the entrance to the cycle. This bears similarity to Linked List Cycle II. The solution is to use fast and slow pointers as before, with some insights from math to find the entrance.\n\nWe define the following variables (see diagram above): - \\(F\\): the distance from the start of the array to the entrance of the cycle - \\(a\\): the distance from the entrance of the cycle to the meeting point of the fast and slow pointers - \\(C\\): the length of the cycle\nAt the intersection point i.e., where two pointers meet, we have the following equations: \\[2 \\times \\text{distance slow pointer moves} = \\text{distance fast pointer moves}\\]\nWhich is equivalent to: \\[\n2(F + a) = F + a + nC, \\text{for some n} \\in \\mathbb{N}\n\\] This gives us an interesting equation: \\[\nF = (n-1)C + (C - a)\n\\] In plain English, this means that if the two pointers both start at first element, the distance from the intersection point found to the cycle entrance is equal to the distance from that first element to the cycle entrance. This means that if we move one pointer back to the first element and move both pointers one step at a time, they will meet at the cycle entrance.\n\n\nAlgorithm\n\n\nSet the fast and slow pointers to the first element of the array.\nMove the fast pointer two steps and the slow pointer one step at a time, until they meet.\nSet the slow pointer to the first element of the array.\nMove both pointers one step at a time, until they meet.\nReturn the meeting point.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): We need to traverse the array a number of time.\nSpace complexity:  \\(O(1)\\): We only need to store pointers.\n\n\n\nCode\nclass Solution:\n    def findDuplicate(self, nums: List[int]) -&gt; int:\n        # Phase 1: Intersection point\n        fast = slow = nums[0]\n        while True:\n            fast = nums[nums[fast]]\n            slow = nums[slow]\n            if fast == slow:\n                break\n        \n        # Phase 2: Find the cycle entrance\n        slow = nums[0]\n        while slow != fast:\n            fast = nums[fast]\n            slow = nums[slow]\n        \n        return slow"
  },
  {
    "objectID": "posts/linked_list/index.html",
    "href": "posts/linked_list/index.html",
    "title": "Linked List",
    "section": "",
    "text": "Firstly, See About page."
  },
  {
    "objectID": "posts/linked_list/index.html#definitions",
    "href": "posts/linked_list/index.html#definitions",
    "title": "Linked List",
    "section": "Definitions:",
    "text": "Definitions:\n\nA nonlinear data structure consists of nodes with pointers to the next nodes.\nA linked list can be singly-linked, or doubly-linked, with just head pointer or together with tail pointer.\nFor LeetCode, a singly-linked list with head pointer is usually given.\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nMay fall under many patterns, such as fast and slow pointers."
  },
  {
    "objectID": "posts/linked_list/index.html#general-trick",
    "href": "posts/linked_list/index.html#general-trick",
    "title": "Linked List",
    "section": "General trick:",
    "text": "General trick:\n\n1. Sentinel head (also tail):\nWe create a dummy head first, modify everything after, and then return the actual head with dummy.next\ndummy = ListNode(None)\nhead = dummy\n# Do a lot of stuff with head\nreturn dummy.next\nThis is useful as we can use the head as a pointer to traverse the linked list while still need to return the head of the linked list in result."
  },
  {
    "objectID": "posts/linked_list/index.html#problems",
    "href": "posts/linked_list/index.html#problems",
    "title": "Linked List",
    "section": "Problems:",
    "text": "Problems:\n\n1. Reverse Linked List\n\nIntuition\n\nThis is what I call a basic problem - a problem that can be become a sub-problem for a bigger task in the future LeetCode problems. This is like a formula that you have no choice but to remember (coding interview is still closed-book at the moment, year 2023), and then exploit it over and over again.\n\n\nAlgorithm\n\nWhen dealing with Linked List, the king is pointer - something as dangerous as pointing gun to your headan object that points to the particular position of a node in the list. The number of pointers a problem requires depend on the amount of information we need at when processing each node in the list. Here, we need to know 3 pieces: the current node (obviously), the previous node to point the current node to, and the next node to move the pointer. Hence, we will use three pointers - pre, cur, and nex to keep track while traversing the list.\n\n\nComplexity\n\nTime complexity: \\(O(n)\\): Traversing the whole list once. \nSpace complexity: \\(O(1)\\): Pointers are essentially integers, taking constant memory \n\n\n\nCode\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        # Easy case:\n        if head is None or head.next is None:\n            return head\n        \n        # General case:\n        pre, cur, nex = None, head, head.next\n        while nex:\n            cur.next = pre\n            pre = cur\n            cur = nex\n            nex = nex.next\n        cur.next = pre\n        return cur\n\n\n\n2. Merge Two Sorted Lists\nChoose a new linked list. Move the two head pointers down the two lists, compare the nodes, and splice them accordingly.\n\nIntuition\n\n\n\nAlgorithm\n\n\n\nComplexity\n\nTime complexity: \nSpace complexity: \n\n\n\nCode\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:\n        # Easy case\n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        # General case\n        # Most straightforward way is to create a new linked list\n        # Utilize the sentinel head trick here\n        dummy = ListNode()\n        head = dummy\n\n        # One list will reach the end before the other, so it is divided into 2 steps:\n        # 1. Compare and splice the nodes in the two list\n        # 2. Add the rest of one list to the end of the result.\n        while list1 and list2:\n            if list1.val &lt;= list2.val:\n                head.next = list1\n                list1 = list1.next\n            else:\n                head.next = list2\n                list2 = list2.next\n            head = head.next\n        \n        if list1:\n            head.next = list1\n        elif list2:\n            head.next = list2\n        \n        return dummy.next\n\n\n\n5. Reorder List\nThe task can be divided into 3 parts:\n\nDivide the original list into 2.\nReverse the second half.\nMerge the two halves.\n\nHere we saw for the first time all the problems above come together into one problem. Here you see that I turned the second part into another hidden method within the Solution class. This is one way to do it. Another is to define the function within the function (nested function), which you will see many Python LeetCoders do. These two methods are equivalent in solving LeetCode problems. For outside world, I think that my current method is more appreciated, as of here.\n\nIntuition\n\n\n\nAlgorithm\n\n\n\nComplexity\n\nTime complexity: \nSpace complexity: \n\n\n\nCode\nclass Solution:\n    def _reverseList(self, head: ListNode):\n        pre, cur, nex = None, head, head.next\n        while nex:\n            cur.next = pre\n            pre = cur\n            cur = nex\n            nex = nex.next\n        cur.next = pre\n        return cur\n    def reorderList(self, head: Optional[ListNode]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify head in-place instead.\n        \"\"\"\n        # Easy case:\n        if head.next is None or head.next.next is None:\n            return\n        \n        # General case:\n        fast = slow = temp1 = temp2 = head\n        while fast.next and fast.next.next:\n            fast = fast.next.next\n            slow = slow.next\n        temp2 = slow.next\n        slow.next = None\n        del slow, fast\n        temp2 = self._reverseList(temp2)\n        nex1, nex2 = temp1.next, temp2.next\n        while nex2:\n            temp1.next = temp2\n            temp2.next = nex1\n            temp1, temp2 = nex1, nex2\n            nex1, nex2 = nex1.next, nex2.next\n        temp1.next = temp2\n        if nex1:\n            temp2.next = nex1\n\n\n\n6. Find the Duplicate Number\nThis is not a Linked List question, but it utilizes the fast and slow pointers to turn it into a linked list question in the subtlest way possible. As noted in the editorial, this is similar to Linked List Cycle II. In the original one, fast and slow pointer is used to detect the cycle. Now the objective is to return the cycle entrance. Fast and slow pointers can be proved mathematically to work for that problem, by having the fast pointer starts at the intersection and the slow pointer starts at the start, they will meet each other at the entrance!\n\nIntuition\n\n\n\nAlgorithm\n\n\n\nComplexity\n\nTime complexity: \nSpace complexity: \n\n\n\nCode\nclass Solution:\n    def findDuplicate(self, nums: List[int]) -&gt; int:\n        # Phase 1: Intersection point\n        fast = slow = nums[0]\n        while True:\n            fast = nums[nums[fast]]\n            slow = nums[slow]\n            if fast == slow:\n                break\n        \n        # Phase 2: Find the cycle entrance\n        slow = nums[0]\n        while slow != fast:\n            fast = nums[fast]\n            slow = nums[slow]\n        \n        return slow\n\n\n\n7. Copy List with Random Pointer\nSometimes overthinking is a big problem. This question is super hard - if you try to do it in one go. The secret is to not do so. You do it in 2 passes. And use a HashMap to keep track of the copy.\n\nIntuition\n\n\n\nAlgorithm\n\n\n\nComplexity\n\nTime complexity: \nSpace complexity: \n\n\n\nCode\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -&gt; 'Optional[Node]':\n        # The first key in the dictionary to deal with the pointer to \n        # None of a node.\n        oldToCopy = {None: None}\n\n        # 1st pass: Create all the nodes only\n        cur = head\n        while cur:\n            oldToCopy[cur] = Node(cur.val)\n            cur = cur.next\n        \n        # 2nd pass: Create the links within the list\n        cur = head\n        while cur:\n            copy = oldToCopy[cur]\n            copy.next = oldToCopy[cur.next]\n            copy.random = oldToCopy[cur.random]\n            cur = cur.next\n        \n        return oldToCopy[head]\n\n\n\n8. Palindrome Linked List\nHere we see the reverse linked list sub-problem becomes relevant again. The algorithm is:\n\nGo to the middle of the linked list and divide it in 2 halves.\nReverse the second half.\nCheck each pair of nodes of two halves and return result.\n\n\nIntuition\n\n\n\nAlgorithm\n\n\n\nComplexity\n\nTime complexity: \nSpace complexity: \n\n\n\nCode\nclass Solution:\n    def _reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        pre, cur, nex = None, head, head.next\n        while nex:\n            cur.next = pre\n            pre = cur\n            cur = nex\n            nex = nex.next\n        cur.next = pre\n        return cur\n\n    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:\n        # Easy case:\n        if head is None or head.next is None:\n            return True\n        \n        # General case:\n        slow, fast = head, head.next\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        if not fast.next:\n            temp = slow.next\n            slow.next = None\n        else:\n            temp = slow.next.next\n            slow.next.next = None\n        temp = self._reverseList(temp)\n        while temp:\n            if temp.val != head.val:\n                return False\n            temp, head = temp.next, head.next\n        return True\n\n\n\n9. Add Two Numbers\nThe second problem added to LeetCode, after Two Sum. The digits are arranged in reverse order, which makes it easier to add them. The algorithm can be represented as:\n\nWhile both heads not yet hit the end, traverse and add each pair of digit (remember to log the remaining).\nWhen a head hits the end, check if the remaining list has any node left and add them to the result.\n\n\nIntuition\n\n\n\nAlgorithm\n\n\n\nComplexity\n\nTime complexity: \nSpace complexity: \n\n\n\nCode\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n        dummy = ListNode()\n        head = dummy\n        remain = 0\n        while l1 and l2:\n            raw_sum = l1.val + l2.val + remain\n            remain = raw_sum // 10\n            temp_sum = raw_sum % 10\n            head.next = ListNode(temp_sum)\n            head = head.next\n            l1, l2 = l1.next, l2.next\n        \n        while l1:\n            if remain == 0:\n                head.next = l1\n                break\n            raw_sum = l1.val + remain\n            remain = raw_sum // 10\n            temp_sum = raw_sum % 10\n            head.next = ListNode(temp_sum)\n            head = head.next\n            l1 = l1.next\n        \n        while l2:\n            if remain == 0:\n                head.next = l2\n                break\n            raw_sum = l2.val + remain\n            remain = raw_sum // 10\n            temp_sum = raw_sum % 10\n            head.next = ListNode(temp_sum)\n            head = head.next\n            l2 = l2.next\n        if remain != 0:\n            head.next = ListNode(remain)\n        return dummy.next\n\n\n\n10. LRU Cache\n\nIntuition\n\n\n\nAlgorithm\n\n\n\nComplexity\n\nTime complexity: \nSpace complexity: \n\n\n\nCode"
  },
  {
    "objectID": "posts/sliding_window/index.html",
    "href": "posts/sliding_window/index.html",
    "title": "Sliding window",
    "section": "",
    "text": "Firstly, See About page."
  },
  {
    "objectID": "posts/sliding_window/index.html#definitions",
    "href": "posts/sliding_window/index.html#definitions",
    "title": "Sliding window",
    "section": "Definitions",
    "text": "Definitions\nSliding window at its core is processing the data in an array in chunk, with limits set by 2 pointers at both sides. Sliding window is particularly suitable if we need to performf repeated operations on a sub-array. Instead of going crazy over all of the possible chunks, we can just change the result (e.g. sum of elements in the window) by discarding the leaving and accounting for the entering element(s)."
  },
  {
    "objectID": "posts/sliding_window/index.html#problems",
    "href": "posts/sliding_window/index.html#problems",
    "title": "Sliding window",
    "section": "Problems",
    "text": "Problems\n\n1. Best Time to Buy and Sell Stock\n\nIntuition\n\nThe first problem in sliding window. The brute-force way of doing this is to check every single pair fo number for the largest right-left pair. The time complexity will be \\(O(n^2)\\). How do we modify this solution to be easier?\nFirst, the brute-force algorithm involves keeping track of the maximum number so far. This is a good thing that we can keep.\nSecond, let’s assume this array of [2, ..., 1]. Let’s say that the maximum of the subarray between 2 and 1 is 6: [2, ...6..., 1] (it does not matter where the 6 is as long as it occurs before 1). The max profit we can get so far is \\(6-2=4\\). To increase the profit, there are two ways: shift the buy date to a day with smaller price, or shift the sell date to a day with a larger price. Let’s say there is a 7 after 1. We can increase the profit if we shift the sell date from 6 to 7: [2, ...6..., 1, ...7...]. However, the best profit is when we shift the buy date from 2 to 1 as well. Now, because we already keep track of the max profit so far, so it cannot be worse if we shift the buy date every single time we find a better buy date.\n\n\nAlgorithm\n\nThe algorithm: 1. Initialize the left and right sides of the window + the max profit so far. 2. Traverse the array with the right side. 3. If we encounter a better buy date (right &lt; left), update the buy date. If we encounter a potential sell date (right &gt;= left), check and update the profit so far. 4. Return the max profit at the end. #### Complexity - Time complexity:  \\(O(n)\\): We are traversing the array once. - Space complexity:  \\(O(1)\\): We are only keeping track of a bunch of integers. #### Code\nclass Solution:\n    def maxProfit(self, prices: List[int]) -&gt; int:\n        buyDay = maxProfit = 0\n        for sellDay in range(len(prices)):\n            if prices[sellDay] &lt; prices[buyDay]:\n                buyDay = sellDay\n            else:\n                currentProfit = prices[sellDay] - prices[buyDay]\n                if currentProfit &gt; maxProfit:\n                    maxProfit = currentProfit\n        return maxProfit\n\n\n\n2. Maximum Subarray:\n\nIntuition\n\nThis is one problem in the class of “if you know, you know”, though of course you can discover for yourself from keen observation.\nThe named algorithm is Kadane’s algorithm. I did not know the exact formal definition for it, but its pattern is that of sliding window (though the class will be dynamic programming). The intuition here is that if we keep track of the sum of a subarray, one that sum reaches a negative number, the whole subarray can be discarded from consideration, because whatever the value of the next element, the subarray sum will always be worse if we include the negative-sum subarray. Incredible intuition, though I could not see this in the first time I did it.\n\n\nAlgorithm\n\n\nTraverse the array, keeping track of the current sum curSum and the maximum sum so far maxSum of the array.\nAt each element, if curSum becomes negative, we reset it to 0 first. Then we add the element to curSum. If curSum becomes larger than maxSum, we update maxSum.\nIf we reach the end of the array, return maxSum.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): Traversing the whole array once.\nSpace complexity:  \\(O(1)\\): We just need to keep track of a bunch of integers.\n\n\n\nCode\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -&gt; int:\n        curSum, maxSum = 0, float('-inf')\n        for num in nums:\n            if curSum &lt; 0:\n                curSum = 0\n            curSum += num\n            if curSum &gt; maxSum:\n                maxSum = curSum\n        return maxSum"
  },
  {
    "objectID": "posts/stack/index.html",
    "href": "posts/stack/index.html",
    "title": "Stack",
    "section": "",
    "text": "Firstly, See About page."
  },
  {
    "objectID": "posts/stack/index.html#definitions",
    "href": "posts/stack/index.html#definitions",
    "title": "Stack",
    "section": "Definitions:",
    "text": "Definitions:\nA data structure with the trademark of LIFO (last in, first out). It has direct analogy to the list in Python, and we actually will use the built-in list as the stack. There are alternatives to have a stack (such as queue.LifoQueue), but normally, a python list suffices."
  },
  {
    "objectID": "posts/stack/index.html#problems",
    "href": "posts/stack/index.html#problems",
    "title": "Stack",
    "section": "Problems:",
    "text": "Problems:\n\n1. Valid Parentheses\n\nIntuition\n\nThis is the Two Sum of stack. The problem requirements can be translated into the intuition that if we push the left parenthesis into a stack and pop them out whenever we encounter a right parenthesis, the correct parenthesis sequence will generate all matching pairs.\n\n\nAlgorithm\n\n\nInitialize, including a HashMap for right and left parenthesis, and check that the array has an even number of elements.\nTraverse the array of parentheses.\nIf we encounter a left parenthesis, push it to a stack.\nIf we encounter a right parenthesis, compare it to the one we pop from the stack. If they do not match, return False immediately.\nAt the end, return True if the stack is empty, else False.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): Traversing the whole array once.\nSpace complexity:  \\(O(n)\\): At the worst case, we will need to store half of the array inside the stack.\n\n\n\nCode\nclass Solution:\n    def isValid(self, s: str) -&gt; bool:\n        if len(s) % 2:\n            return False\n        stack = []\n        parenthesisDict = {'{':'}', '[':']', '(':')'}\n        for parenthesis in s:\n            if parenthesis in parenthesisDict:\n                stack.append(parenthesis)\n            else:\n                if len(stack) == 0 or parenthesis != parenthesisDict[stack.pop()]:\n                    return False\n        return len(stack) == 0\n\n\n\n2. Evaluate Reverse Polish Notation\n\nIntuition\n\nThe notation works perfectly with a stack. Basically, whenever you encounter an operand, you need to pop from the end of the stack and perform operation in the correct order before append the result to the stack. Otherwise, just append the numbers in the order we encounter them.\n\n\nAlgorithm\n\n\nTraverse the list.\nIf encounter a number, append it to the stack. If encounter an operand, pop from the stack two times, operate, and append the result.\nReturn the result.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): Traversing the whole array once.\nSpace complexity:  \\(O(n)\\): At the worst case, we will need to store more than half of the array inside the stack.\n\n\n\nCode\nclass Solution:\n    def evalRPN(self, tokens: List[str]) -&gt; int:\n        stack = []\n        for token in tokens:\n            if token =='+':\n                a, b = stack.pop(), stack.pop()\n                stack.append(a+b)\n            elif token =='*':\n                a, b = stack.pop(), stack.pop()\n                stack.append(a*b)\n            elif token =='/':\n                a, b = stack.pop(), stack.pop()\n                stack.append(int(b/a))\n            elif token =='-':\n                a, b = stack.pop(), stack.pop()\n                stack.append(b-a)\n            else:\n                stack.append(int(token))\n        return stack.pop()\n\n\n\n3. Daily Temperatures\n\nIntuition\n\nThe number of days to wait is the difference in the indices of the days. The stack comes in handy here by storing the value of the element sequentially, and then we pop from it when we encounter a day with larger temperature.\n\n\nAlgorithm\n\n\nInitialize the stack and the answer array, which is an array of 0s with the same length as temperatures.\nTraverse the array. Storing the value and index to a stack if the value is not larger than the last element in the stack. Pop from the stack and update answer otherwise.\nReturn answer.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): Traversing the whole array once.\nSpace complexity:  \\(O(n)\\): At the worst case, we will need to store nearly the whole array inside the stack.\n\n\n\nCode\nclass Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -&gt; List[int]:\n        answer = [0]*len(temperatures)\n        stack = []\n        for ind, temp in enumerate(temperatures):\n            while stack and stack[-1][0] &lt; temp:\n                stackTemp, stackInd = stack.pop()\n                answer[stackInd] = ind - stackInd\n            stack.append((temp, ind))\n        return answer\n\n\n\n4. Min Stack\n\nIntuition\n\nThe trick is having another stack to store the minimum so far.\n\n\nAlgorithm\n\nWith the minimum so far stack, we just need to update it along with the main stack. The main task will be the push operation, where we need to append the new value if it is the new minimum, or the same last value.\n\n\nComplexity\n\nTime complexity:  As required by the problem, everything is in \\(O(1)\\) time.\nSpace complexity:  We are using two stacks, so it is double the memory. Nevertheless, it is \\(O(n)\\).\n\n\n\nCode\nclass MinStack:\n    # The trick is having the min stack so far\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val: int) -&gt; None:\n        self.stack.append(val)\n        if not self.min_stack or val &lt; self.min_stack[-1]:\n            self.min_stack.append(val)\n        else:\n            self.min_stack.append(self.min_stack[-1])\n\n    def pop(self) -&gt; None:\n        self.stack.pop()\n        self.min_stack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1]\n\n    def getMin(self) -&gt; int:\n        return self.min_stack[-1]\n\n\n# Your MinStack object will be instantiated and called as such:\n# obj = MinStack()\n# obj.push(val)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.getMin()\n\n\n\n5. Generate Parentheses\n\nIntuition\n\nThe problem gave me a taste of backtracking. It is time to realize that this is possible. Backtracking is built on recursion, which is built on the recursion call stack. So yeah, stack will be present in recursion problem.\nIn recursion problem, we start with the base case. The base case here revolves around the condition to add left and right parentheses. Simply, we can validly add a left parenthesis if the number of left parentheses is smaller than \\(n\\), while we can validly add a right parenthesis if the number of left parentheses is smaller than the number of right parentheses. The base case is when the number of left and the number of right all hit \\(n\\).\n\n\nAlgorithm\n\n\nInitialize res and stack array. One to return, one to keep track of the string generated.\nDefine the backtracking function backtrack based on the conditions above.\nCall backtrack to update res and return.\n\n\n\nComplexity\n\nTime complexity:  \\(O(\\frac{4^n}{\\sqrt n})\\): It is complicated to derive this time complexity, related to Catalan numbers. An alternative is remembering the brute-force time complexity: \\(O(2^{2n}*n)\\). At each position in the \\(2n\\) string there are two ways to choose which parenthesis to add, and checking for validity takes \\(O(n)\\) time.\nSpace complexity:  \\(O(n)\\): The maximum depth of the recursive stack.\n\n\n\nCode\nclass Solution:\n    def generateParenthesis(self, n: int) -&gt; List[str]:\n        # Backtracking problem\n        # Revolve around conditions to add open parenthesis and\n        # closed parenthesis\n        # Open parenthesis can be added if it is less than n\n        # Closed parenthesis can be added if it is less than open\n        stack, res = [], []\n        \n        def backtrack(openN, closedN):\n            if openN == closedN == n:\n                res.append(''.join(stack))\n                return\n            \n            if openN &lt; n:\n                stack.append('(')\n                backtrack(openN+1, closedN)\n                stack.pop()\n            \n            if closedN &lt; openN:\n                stack.append(')')\n                backtrack(openN, closedN+1)\n                stack.pop()\n        backtrack(0, 0)\n        return res\n\n\n\n6. Largest Rectangle In Histogram\n\nIntuition\n\nThe trick revolves around the condition to extend the rectangle. We can extend the rectangle if the current height is larger than the previous height. If not, we need to pop from the stack, calculate the area of the rectangle and update the maximum area. The next bit is storing the index of the last element that the current height can extend back to instead of its own index.\n\n\nAlgorithm\n\n\nInitialize maxArea and stack array. One to return, one to keep track of the (index, height) pairs.\nIterate the heights arrray. At each height, if it is smaller than the previous one and the stack is not empty, we pop from the stack, calculate the maximum height possible, update maxArea if necessary, and push (index, height) pair to the stack.\nBefore return, we need to calculate the area of every rectangle left in the stack. The area is calculated by the height of the rectangle times the width, which is the difference between the current index and the index of the last element in the stack. Update maxArea if necessary and return.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): We iterate through the heights array once, and the stack once.\nSpace complexity:  \\(O(n)\\): In the worst case, the stack will be the same size as the heights array.\n\n\n\nCode\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -&gt; int:\n        maxArea = 0\n        stack = [] # (index, height)\n\n        for i, h in enumerate(heights):\n            start = i\n            while stack and stack[-1][1] &gt; h:\n                index, height = stack.pop()\n                maxArea = max(maxArea, height * (i-index))\n                start = index\n            stack.append((start, h))\n        \n        for i, h in stack:\n            maxArea = max(maxArea, h * (len(heights)-i))\n        \n        return maxArea"
  },
  {
    "objectID": "posts/two_pointers/index.html",
    "href": "posts/two_pointers/index.html",
    "title": "Two pointers",
    "section": "",
    "text": "Firstly, See About page."
  },
  {
    "objectID": "posts/two_pointers/index.html#definitions",
    "href": "posts/two_pointers/index.html#definitions",
    "title": "Two pointers",
    "section": "Definitions:",
    "text": "Definitions:\nThis is not a data structure, but a pattern of coding interview questions. This is something passed down from languages with pointers such as C++ or Java. The idea is that we will traverse the array in both direction. This operation has use in some problems, particularly palindrome checking."
  },
  {
    "objectID": "posts/two_pointers/index.html#problem",
    "href": "posts/two_pointers/index.html#problem",
    "title": "Two pointers",
    "section": "Problem",
    "text": "Problem\n\n1. Valid Palindrome\n\nIntuition\n\nThe basic problem of two pointers. The problem can be solved by many ways (strip the string then reverse, etc.), but the most straightforward way if you know two pointers is using two pointers. You will traverse the string in both directions, bypassing non-alphanumeric characters. For each alphanumeric pairs, the lowercase versions of the character must match.\n\n\nAlgorithm\n\n\nInitialize two pointers.\nTraverse the array from both ends.\nFor both pointers, if we encounter a non-alphanumeric characters, we increment or decrement further.\nIf we encounter a differing pair, return False immediately.\nAt the end, return True if the right end (or the left end, depending on which pointer is moved first) has moved, else False (this is to resolve edge cases suchas \".,\").\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): Traversin the whole array once. g\nSpace complexity:  \\(O(1)\\): Pointers are essentially integers.\n\n\n\nCode\nclass Solution:\n    def isPalindrome(self, s: str) -&gt; bool:\n        # Edge case\n        if len(s) &lt; 2:\n            return True\n\n        # General case\n        leftPointer, rightPointer = 0, len(s) - 1\n        while leftPointer &lt;= rightPointer:\n            while (leftPointer &lt; rightPointer) and (not s[leftPointer].isalnum()):\n                leftPointer += 1\n            while (leftPointer &lt; rightPointer) and (not s[rightPointer].isalnum()):\n                rightPointer -= 1\n            \n            if s[leftPointer].lower() != s[rightPointer].lower():\n                return False\n            leftPointer += 1\n            rightPointer -= 1\n        \n        return rightPointer &lt; len(s) - 1\n\n\n\n2. Two Sum II - Input Array Is Sorted\n\nIntuition\n\nIf we set up two pointers at the start and the end, if the sum of the two numbers is larger, the only way to make it smaller is to decrement the right pointer. Likewise, the only way to make it larger is to increment the left pointer.\n\n\nAlgorithm\n\n\nInitialize two pointers.\nTraverse the array, decrement the right and increment the left accordingly.\nReturn the required indices when found.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): Traversin the whole array once.\nSpace complexity:  \\(O(1)\\): Pointers are essentially integers.\n\n\n\nCode\nclass Solution:\n    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:\n        left, right = 0, len(numbers)-1\n        while left &lt; right:\n            while numbers[left] + numbers[right] &gt; target:\n                right -= 1\n            while numbers[left] + numbers[right] &lt; target:\n                left += 1\n            if numbers[left] + numbers[right] == target:\n                return [left+1, right+1]\n\n\n\n3. 3Sum\n\nIntuition\n\nIf we sort the array, the problem can be turned into a two-pointer problem, where we fix the first value and then use two pointers to search for the remaining two values. There arises a bigger problem though: dealing with duplicates. The best approach is to deal with duplicates after we have found a satisfying triplet.\n\n\nAlgorithm\n\n\nSort the array\nNested for loop: Traverse the array. For each value, traverse the remaining array with two pointers to look for the satisfying triplets. Take care to deal with duplicates after finding a satisfying triplet.\nReturn the result.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n^2)\\): We use a nested for loop to traverse the array.\nSpace complexity:  \\(O(1)\\): If we ignore the returning array. If not, the complexity is \\(O(k)\\) for k the number of triplets.\n\n\n\nCode\nclass Solution:\n    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:\n        if len(nums) == 3:\n            return [nums] if sum(nums) == 0 else []\n        nums.sort()\n        cur, res = 0, []\n        while cur &lt; len(nums) - 2:\n            # A nice little improvement: once the smallest value is positive, we\n            # can safely conclude the search.\n            if nums[cur] &gt; 0:\n                break\n            left, right = cur + 1, len(nums) - 1\n            remain = - nums[cur]\n            while left &lt; right:\n                # print('Sum:', nums[left] + nums[right])\n                if nums[left] + nums[right] &lt; remain:\n                    left += 1\n                elif nums[left] + nums[right] &gt; remain:\n                    right -= 1\n                elif nums[left] + nums[right] == remain:\n                    res.append([nums[left], nums[right], nums[cur]])\n                    # This is where we decrement and increment the pointers to deal with duplicates. \n                    while left &lt; len(nums)-1 and nums[left+1] == nums[left]:\n                        left += 1\n                    while left &lt; len(nums)-1 and nums[right-1] == nums[right]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n            while cur &lt; len(nums) - 2 and nums[cur+1] == nums[cur]:\n                cur += 1\n            cur += 1\n        return res\n\n\n\n4. Container With Most Water\n\nIntuition\n\nThe trick is the idea of maximum so far. This appears a lot in problems where we need to iterate the array and update an extremum as we go along. The rule for moving the pointer comes from the question: How do I potentially increase the value of maximum area so far?. The answer is by moving the smaller pointer, the bottleneck in calculating the amount of water the container can hold.\nAn improvement on the solution is a simple check-up. Taking the width constant, the best container is the one with the maximum height. Therefore, at any moment the volume of the best container possible with the current width cannot surpass the maximum so far, we can safely break out of the for loop.\n\n\nAlgorithm\n\n\nInitialize: 2 pointers, maximum so far, and maximum height.\nTraverse the array with two pointers. Update the maximum height as we go along.\nOnce the terminating condition is met, return the maximum so far.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): We need to traverse the array once…\nSpace complexity:  \\(O(1)\\): … and store a bunch of integers.\n\n\n\nCode\nclass Solution:\n    def maxArea(self, height: List[int]) -&gt; int:\n        maxSoFar = -1\n        left, right = 0, len(height)-1\n        maxHeight = max(height)\n        while left &lt; right:\n            minHeight = min(height[left], height[right])\n            maxSoFar = max(maxSoFar, (right-left)*minHeight)\n            if height[left] == minHeight:\n                left += 1\n            else:\n                right -= 1\n            if maxHeight*(right - left) &lt;= maxSoFar:\n                break\n        return maxSoFar        \n\n\n\n5. Trapping Rain Water\n\nIntuition\n\n\nDeal with the calculation one element at a time.\nNeed to keep the maximum left and right heights.\nThe water trapped depends on the smaller maximum height.\nLet’s say the maximum left height is smaller. The water trapped is the difference between the maximum left height and the current left height, which is &gt;= 0.\nWe need to increment the side with the smaller maximum height.\n\n\n\nAlgorithm\n\n\nInitialize pointer and maximum height for each side.\nTraverse the array. Increment the side with the smaller maximum height. Update the maximum height at that side and the water trapped so far.\nReturn the result.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): We need to traverse the array once…\nSpace complexity:  \\(O(1)\\): … and store a bunch of integers.\n\n\n\nCode\nclass Solution:\n    def trap(self, height: List[int]) -&gt; int:\n        if not height:\n            return 0\n        left, right = 0, len(height) - 1\n        leftMax, rightMax=  height[left], height[right]\n        res = 0\n        while left &lt; right:\n            if leftMax &lt; rightMax:\n                left += 1\n                leftMax = max(leftMax, height[left])\n                res += leftMax - height[left]\n            else:\n                right -= 1\n                rightMax = max(rightMax, height[right])\n                res += rightMax - height[right]\n        return res\n\n\n\n6. Reverse Words in a String\n\nIntuition\n\nLet’s forget about the Python one-liner despite its performance - you can take a look at it at the end. It will not help you learn anything besides the power of reading the documentation.\nBack to the problem. If we are not in Python, we will need to convert the string into a mutable array, reverse every character in the array, and then iterate and reverse every character in word, which came before a white space or at the end. The last bit can be done with two pointers.\n(We can also define a function to reverse every element in a list. I don’t want to go that far so I will just use the built-in Python one.)\n\n\nAlgorithm\n\n\nProcess the string to remove extra whitespaces.\nConvert the string to a list of character and reverse it.\nIterate the list of character, reverse every character in a word.\nJoin the characters back and return.\n\n\n\nComplexity\n\nTime complexity:  \\(O(n)\\): We need to iterate the list of characters two times. Note that the two times are not nested.\nSpace complexity:  \\(O(n)\\): We need to create the list of characters #### Code\n\nimport re\n\nclass Solution:\n    def reverseWords(self, s: str) -&gt; str:\n        if len(s) &lt; 2:\n            return s\n\n        sentence = re.sub(' +', ' ', s.strip())\n        # General one\n        # Convert the string into a list of characters and reverse it\n        sentence = list(sentence)\n        sentence = sentence[::-1]\n\n        # Iterate and reverse each word back\n        # A word exists before each space\n        start, end = 0, 1\n        while start &lt; len(sentence):\n            while end &lt; len(sentence) and sentence[end] != ' ':\n                end += 1\n            self._reverseWords(sentence, start, end-1)\n            start = end + 1\n            end += 1\n        return ''.join(sentence)\n\n    def _reverseWords(self, sentence, start, end):\n        while start &lt;= end:\n            temp = sentence[start]\n            sentence[start] = sentence[end]\n            sentence[end] = temp\n\n            start += 1\n            end -= 1\n        \nTrivial Python solution\n# Trivial Python solution\nclass Solution:\n    def reverseWords(self, s: str) -&gt; str:\n        return \" \".join(s.split()[::-1])\n\n\n\n7. Valid Palindrome II\n\nIntuition\n\nThis problem builds upon Valid Palindrome I. The intuition is this: if we iterate the string with two pointers as before, at the first pair where two characters are different, the string is valid if the substring from the element right next to the right of the left character in the pair to the right character in the pair is a valid palindrome, or the substring from the left character in the pair to the element right next to the left of the right character in the pair is a valid palindrome.\n\n\nAlgorithm\n\n\nIterate the string with two pointers. Check for similarity as with normal valid palindrome problem.\nIf encountered dissimilarity, check valid palindrome for the two substrings mentioned above and return.\nReturn result at the end.\n\n\n\nComplexity\nThere are two ways to write solutions: hidden class method and nonlocal keyword.\n\nTime complexity:  \\(O(n)\\): We need to iterate through the input string once in both cases.\nSpace complexity:  \\(O(1)\\): We only need to store pointers.\n\n\n\nCode\nThis is the proper hidden class method solution.\nclass Solution:\n    def validPalindrome(self, s: str) -&gt; bool:\n        start, end = 0, len(s) - 1\n        while start &lt; end:\n            if s[start] != s[end]:\n                return (self._checkPalindrome(s[start+1:end+1]) or self._checkPalindrome(s[start:end]))\n            start += 1\n            end -= 1\n        return True\n    \n    def _checkPalindrome(self, s: str) -&gt; bool:\n        left, right = 0, len(s)-1\n        while left &lt; right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\nAnd this is the nested function solution.\nclass Solution:\n    def validPalindrome(self, s: str) -&gt; bool:\n        \n        def _checkPalindrome(left: int, right: int) -&gt; bool:\n            # nonlocal s\n            while left &lt; right:\n                if s[left] != s[right]:\n                    return False\n                left += 1\n                right -= 1\n            return True\n\n        start, end = 0, len(s) - 1\n        while start &lt; end:\n            if s[start] != s[end]:\n                return (_checkPalindrome(start+1,end) or _checkPalindrome(start,end-1))\n            start += 1\n            end -= 1\n        return True\nThe hidden class function is preferred as it adheres to the single responsibility principle, bringing the benefits including readability, maintainability, and modularity."
  }
]